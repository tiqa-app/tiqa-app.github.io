{"pageProps":{"activeTab":"senior","back":"/topics","questions":[{"slug":"explain-how-custom-elements-works-internally","title":"Explain how custom elements works internally?","answer":"<p>Below are the steps in an order about custom elements functionality,</p>\n<ol>\n<li><strong>App registers custom element with browser:</strong> Use the <code>createCustomElement()</code> function to convert a component into a class that can be registered with the browser as a custom element.</li>\n<li><strong>App adds custom element to DOM:</strong>  Add custom element just like a built-in HTML element directly into the DOM.</li>\n<li><strong>Browser instantiate component based class:</strong> Browser creates an instance of the registered class and adds it to the DOM.</li>\n<li><strong>Instance provides content with data binding and change detection:</strong> The content with in template is rendered using the component and DOM data.</li>\n</ol>\n","level":3},{"slug":"how-to-transfer-components-to-custom-elements","title":"How to transfer components to custom elements?","answer":"<p>Transforming components to custom elements involves <strong>two</strong> major steps,</p>\n<ol>\n<li><strong>Build custom element class:</strong> Angular provides the <code>createCustomElement()</code> function for converting an Angular component (along with its dependencies) to a custom element. The conversion process implements <code>NgElementConstructor</code> interface, and creates a constructor class which is used to produce a self-bootstrapping instance of Angular component.</li>\n<li><strong>Register element class with browser:</strong> It uses <code>customElements.define()</code> JS function, to register the configured constructor and its associated custom-element tag with the browser&#39;s <code>CustomElementRegistry</code>. When the browser encounters the tag for the registered element, it uses the constructor to create a custom-element instance.</li>\n</ol>\n","level":3},{"slug":"what-are-the-mapping-rules-between-angular-component-and-custom-element","title":"What are the mapping rules between Angular component and custom element?","answer":"<p>The Component properties and logic maps directly into HTML attributes and the browser&#39;s event system. Let us describe them in two steps,</p>\n<ol>\n<li>The createCustomElement() API parses the component input properties with corresponding attributes for the custom element. For example, component @Input(&#39;myInputProp&#39;) converted as custom element attribute <code>my-input-prop</code>.</li>\n<li>The Component outputs are dispatched as HTML Custom Events, with the name of the custom event matching the output name. For example, component @Output() valueChanged = new EventEmitter() converted as custom element with dispatch event as &quot;valueChanged&quot;.</li>\n</ol>\n","level":3},{"slug":"how-do-you-define-typings-for-custom-elements","title":"How do you define typings for custom elements?","answer":"<p>You can use the <code>NgElement</code> and <code>WithProperties</code> types exported from @angular/elements.\nLet&#39;s see how it can be applied by comparing with Angular component.</p>\n<ol>\n<li>The simple container with input property would be as below,<pre><code class=\"language-javascript\">@Component(...)\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyContainer</span> </span>{\n@Input() message: string;\n}</code></pre>\n</li>\n<li>After applying types typescript validates input value and their types,<pre><code class=\"language-javascirpt\">const container = document.createElement(&#x27;my-container&#x27;) as NgElement &amp; WithProperties&lt;{message: string}&gt;;\ncontainer.message = &#x27;Welcome to Angular elements!&#x27;;\ncontainer.message = true;  // &lt;-- ERROR: TypeScript knows this should be a string.\ncontainer.greet = &#x27;News&#x27;;  // &lt;-- ERROR: TypeScript knows there is no `greet` property on `container`.</code></pre>\n</li>\n</ol>\n","level":3},{"slug":"what-are-dynamic-components","title":"What are dynamic components?","answer":"<p>Dynamic components are the components in which components location in the application is not defined at build time.i.e, They are not used in any angular template. But the component is instantiated and placed in the application at runtime.</p>\n","level":3},{"slug":"what-are-the-various-kinds-of-directives","title":"What are the various kinds of directives?","answer":"<p>There are mainly three kinds of directives,</p>\n<ol>\n<li><strong>Components</strong> — These are directives with a template.</li>\n<li><strong>Structural directives</strong> — These directives change the DOM layout by adding and removing DOM elements.</li>\n<li><strong>Attribute directives</strong> — These directives change the appearance or behavior of an element, component, or another directive.</li>\n</ol>\n","level":3},{"slug":"what-are-the-restrictions-of-metadata","title":"What are the restrictions of metadata?","answer":"<p>In Angular, You must write metadata with the following general constraints,</p>\n<ol>\n<li>Write expression syntax with in the supported range of javascript features</li>\n<li>The compiler can only reference symbols which are exported</li>\n<li>Only call the functions supported by the compiler</li>\n<li>Decorated and data-bound class members must be public.</li>\n</ol>\n","level":3},{"slug":"what-are-the-two-phases-of-aot","title":"What are the two phases of AOT?","answer":"<p>The AOT compiler works in three phases,</p>\n<ol>\n<li><strong>Code Analysis:</strong> The compiler records a representation of the source</li>\n<li><strong>Code generation:</strong> It handles the interpretation as well as places restrictions on what it interprets.</li>\n<li><strong>Validation:</strong> In this phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.</li>\n</ol>\n","level":3},{"slug":"can-i-use-arrow-functions-in-aot","title":"Can I use arrow functions in AOT?","answer":"<p>No, Arrow functions or lambda functions can’t be used to assign values to the decorator properties. For example, the following snippet is invalid:</p>\n<pre><code class=\"language-javascript\">@Component({\n<span class=\"hljs-attr\">providers</span>: [{\n<span class=\"hljs-attr\">provide</span>: MyService, <span class=\"hljs-attr\">useFactory</span>: <span class=\"hljs-function\">() =&gt;</span> getService()\n}]\n})</code></pre>\n<p>To fix this, it has to be changed as following exported function:</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">getService</span>(<span class=\"hljs-params\"></span>)</span>{\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> MyService();\n}\n@Component({\n<span class=\"hljs-attr\">providers</span>: [{\n<span class=\"hljs-attr\">provide</span>: MyService, <span class=\"hljs-attr\">useFactory</span>: getService\n}]\n})</code></pre>\n<p>If you still use arrow function, it generates an error node in place of the function. When the compiler later interprets this node, it reports an error to turn the arrow function into an exported function.\n<strong>Note:</strong> From Angular5 onwards, the compiler automatically performs this rewriting while emitting the .js file.</p>\n","level":3},{"slug":"what-is-the-purpose-of-metadata-json-files","title":"What is the purpose of metadata json files?","answer":"<p>The metadata.json file can be treated as a diagram of the overall structure of a decorator&#39;s metadata, represented as an abstract syntax tree(AST). During the analysis phase, the AOT collector scan the metadata recorded in the Angular decorators and outputs metadata information in .metadata.json files, one per .d.ts file.</p>\n","level":3},{"slug":"can-i-use-any-javascript-feature-for-expression-syntax-in-aot","title":"Can I use any javascript feature for expression syntax in AOT?","answer":"<p>No, the AOT collector understands a subset  of (or limited) JavaScript features. If an expression uses unsupported syntax, the collector writes an error node to the .metadata.json file. Later point of time, the compiler reports an error if it needs that piece of metadata to generate the application code.</p>\n","level":3},{"slug":"what-is-folding","title":"What is folding?","answer":"<p>The compiler can only resolve references to exported symbols in the metadata. Where as some of the non-exported members are folded while generating the code. i.e Folding is a process in which the collector evaluate an expression during collection and record the result in the .metadata.json instead of the original expression.\nFor example, the compiler couldn&#39;t refer selector reference because it is not exported</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">let</span> selector = <span class=\"hljs-string\">&#x27;app-root&#x27;</span>;\n@Component({\n<span class=\"hljs-attr\">selector</span>: selector\n})</code></pre>\n<p>Will be folded into inline selector</p>\n<pre><code class=\"language-javascript\">@Component({\n<span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-root&#x27;</span>\n})</code></pre>\n<p>Remember that the compiler can’t fold everything. For example, spread operator on arrays, objects created using new keywords and function calls.</p>\n","level":3},{"slug":"how-do-you-provide-configuration-inheritance","title":"How do you provide configuration inheritance?","answer":"<p>Angular Compiler supports configuration inheritance through extends in the tsconfig.json on angularCompilerOptions. i.e, The configuration from the base file(for example, tsconfig.base.json) are loaded first, then overridden by those in the inheriting config file.</p>\n<pre><code class=\"language-javascript\">{\n<span class=\"hljs-string\">&quot;extends&quot;</span>: <span class=\"hljs-string\">&quot;../tsconfig.base.json&quot;</span>,\n<span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: {\n<span class=\"hljs-string\">&quot;experimentalDecorators&quot;</span>: <span class=\"hljs-literal\">true</span>,\n...\n},\n<span class=\"hljs-string\">&quot;angularCompilerOptions&quot;</span>: {\n<span class=\"hljs-string\">&quot;fullTemplateTypeCheck&quot;</span>: <span class=\"hljs-literal\">true</span>,\n<span class=\"hljs-string\">&quot;preserveWhitespaces&quot;</span>: <span class=\"hljs-literal\">true</span>,\n...\n}\n}</code></pre>\n","level":3},{"slug":"how-do-you-specify-angular-template-compiler-options","title":"How do you specify angular template compiler options?","answer":"<p>The angular template compiler options are specified as members of the <strong>angularCompilerOptions</strong> object in the tsconfig.json file. These options will be specified adjecent to typescript compiler options.</p>\n<pre><code class=\"language-javascript\">{\n<span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: {\n<span class=\"hljs-string\">&quot;experimentalDecorators&quot;</span>: <span class=\"hljs-literal\">true</span>,\n...\n},\n<span class=\"hljs-string\">&quot;angularCompilerOptions&quot;</span>: {\n<span class=\"hljs-string\">&quot;fullTemplateTypeCheck&quot;</span>: <span class=\"hljs-literal\">true</span>,\n<span class=\"hljs-string\">&quot;preserveWhitespaces&quot;</span>: <span class=\"hljs-literal\">true</span>,\n...\n}\n}</code></pre>\n","level":3},{"slug":"how-do-you-enable-binding-expression-validation","title":"How do you enable binding expression validation?","answer":"<p>You can enable binding expression validation explicitly by adding the compiler option <strong>fullTemplateTypeCheck</strong> in the &quot;angularCompilerOptions&quot; of the project&#39;s tsconfig.json. It produces error messages when a type error is detected in a template binding expression.\nFor example, consider the following component:</p>\n<pre><code class=\"language-javascript\">@Component({\n<span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;my-component&#x27;</span>,\n<span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;{{user.contacts.email}}&#x27;</span>\n})\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{\nuser?: User;\n}</code></pre>\n<p>This will produce the following error:</p>\n<pre><code class=\"language-javascript\">my.component.ts.MyComponent.html(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>): : Property <span class=\"hljs-string\">&#x27;contacts&#x27;</span> does not exist on type <span class=\"hljs-string\">&#x27;User&#x27;</span>. Did you mean <span class=\"hljs-string\">&#x27;contact&#x27;</span>?</code></pre>\n","level":3},{"slug":"what-is-the-purpose-of-any-type-cast-function","title":"What is the purpose of any type cast function?","answer":"<p>You can disable binding expression type checking using $any() type cast function(by surrounding the expression). In the following example, the error Property contacts does not exist is suppressed by casting user to the any type.</p>\n<pre><code class=\"language-javascript\">template:\n<span class=\"hljs-string\">&#x27;{{ $any(user).contacts.email }}&#x27;</span></code></pre>\n<p>The $any() cast function also works with this to allow access to undeclared members of the component.</p>\n<pre><code class=\"language-javascript\">template:\n<span class=\"hljs-string\">&#x27;{{ $any(this).contacts.email }}&#x27;</span></code></pre>\n","level":3},{"slug":"what-is-non-null-type-assertion-operator","title":"What is Non null type assertion operator?","answer":"<p>You can use the non-null type assertion operator to suppress the Object is possibly &#39;undefined&#39; error. In the following example, the user and contact properties are always set together, implying that contact is always non-null if user is non-null. The error is suppressed in the example by using contact!.email.</p>\n<pre><code class=\"language-javascript\">@Component({\n<span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;my-component&#x27;</span>,\n<span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">&#x27;&lt;span *ngIf=&quot;user&quot;&gt; {{user.name}} contacted through {{contact!.email}} &lt;/span&gt;&#x27;</span>\n})\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyComponent</span> </span>{\nuser?: User;\ncontact?: Contact;\n<span class=\"hljs-function\"><span class=\"hljs-title\">setData</span>(<span class=\"hljs-params\">user: User, contact: Contact</span>)</span> {\n<span class=\"hljs-built_in\">this</span>.user = user;\n<span class=\"hljs-built_in\">this</span>.contact = contact;\n}\n}</code></pre>\n","level":3},{"slug":"how-to-inject-the-dynamic-script-in-angular","title":"How to inject the dynamic script in angular?","answer":"<p> Using DomSanitizer we can inject the dynamic Html,Style,Script,Url.</p>\n<pre><code>import { Component, OnInit } from &#x27;@angular/core&#x27;;\nimport { DomSanitizer } from &#x27;@angular/platform-browser&#x27;;\n@Component({\nselector: &#x27;my-app&#x27;,\ntemplate: `\n&lt;div [innerHtml]=&quot;htmlSnippet&quot;&gt;&lt;/div&gt;\n`,\n})\nexport class App {\nconstructor(protected sanitizer: DomSanitizer) {}\nhtmlSnippet: string = this.sanitizer.bypassSecurityTrustScript(&quot;&lt;script&gt;safeCode()&lt;/script&gt;&quot;);\n}</code></pre>\n","level":3},{"slug":"what-is-angular-ivy","title":"What is Angular Ivy?","answer":"<p>  Angular Ivy is a new rendering engine for Angular. You can choose to opt in a preview version of Ivy from Angular version 8.</p>\n<ol>\n<li>You can enable ivy in a new project by using the --enable-ivy flag with the ng new command<pre><code class=\"language-bash\">ng new ivy-demo-app --enable-ivy</code></pre>\n</li>\n<li>You can add it to an existing project by adding <code>enableIvy</code> option in the <code>angularCompilerOptions</code> in your project&#39;s <code>tsconfig.app.json</code>.<pre><code class=\"language-javascript\">{\n<span class=\"hljs-string\">&quot;compilerOptions&quot;</span>: { ... },\n<span class=\"hljs-string\">&quot;angularCompilerOptions&quot;</span>: {\n<span class=\"hljs-string\">&quot;enableIvy&quot;</span>: <span class=\"hljs-literal\">true</span>\n}\n}</code></pre>\n</li>\n</ol>\n","level":3},{"slug":"what-are-the-features-included-in-ivy-preview","title":"What are the features included in ivy preview?","answer":"<p>  You can expect below features with Ivy preview,</p>\n<ol>\n<li>Generated code that is easier to read and debug at runtime</li>\n<li>Faster re-build time</li>\n<li>Improved payload size</li>\n<li>Improved template type checking</li>\n</ol>\n","level":3},{"slug":"what-is-angular-language-service","title":"What is Angular Language Service?","answer":"<p>  The Angular Language Service is a way to get completions, errors, hints, and navigation inside your Angular templates whether they are external in an HTML file or embedded in annotations/decorators in a string. It has the ability to autodetect that you are opening an Angular file, reads your <code>tsconfig.json</code> file, finds all the templates you have in your application, and then provides all the language services.</p>\n","level":3},{"slug":"how-do-you-add-web-workers-in-your-application","title":"How do you add web workers in your application?","answer":"<p>  You can add web worker anywhere in your application. For example, If the file that contains your expensive computation is <code>src/app/app.component.ts</code>, you can add a Web Worker using <code>ng generate web-worker app</code> command which will create <code>src/app/app.worker.ts</code> web worker file. This command will perform below actions,</p>\n<ol>\n<li>Configure your project to use Web Workers</li>\n<li>Adds app.worker.ts to receive messages<pre><code class=\"language-javascript\">addEventListener(<span class=\"hljs-string\">&#x27;message&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">{ data }</span>) =&gt;</span> {\n<span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-string\">`worker response to <span class=\"hljs-subst\">${data}</span>`</span>;\npostMessage(response);\n});</code></pre>\n</li>\n<li>The component <code>app.component.ts</code> file updated with web worker file<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> Worker !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span>) {\n<span class=\"hljs-comment\">// Create a new</span>\n<span class=\"hljs-keyword\">const</span> worker = <span class=\"hljs-keyword\">new</span> Worker(<span class=\"hljs-string\">&#x27;./app.worker&#x27;</span>, { <span class=\"hljs-attr\">type</span>: <span class=\"hljs-string\">&#x27;module&#x27;</span> });\nworker.onmessage = <span class=\"hljs-function\">(<span class=\"hljs-params\">{ data }</span>) =&gt;</span> {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;page got message: $\\{data\\}&#x27;</span>);\n};\nworker.postMessage(<span class=\"hljs-string\">&#x27;hello&#x27;</span>);\n} <span class=\"hljs-keyword\">else</span> {\n<span class=\"hljs-comment\">// Web Workers are not supported in this environment.</span>\n}</code></pre>\n</li>\n</ol>\n<p><strong>Note:</strong> You may need to refactor your initial scaffolding web worker code for sending messages to and from.</p>\n","level":3},{"slug":"what-are-the-limitations-with-web-workers","title":"What are the limitations with web workers?","answer":"<p>  You need to remember two important things when using Web Workers in Angular projects,</p>\n<ol>\n<li>Some environments or platforms(like @angular/platform-server) used in Server-side Rendering, don&#39;t support Web Workers. In this case you need to provide a fallback mechanism to perform the computations to work in this environments.</li>\n<li>Running Angular in web worker using <code>@angular/platform-webworker</code> is not yet supported in Angular CLI.</li>\n</ol>\n","level":3},{"slug":"what-is-angular-cli-builder","title":"What is Angular CLI Builder?","answer":"<p>  In Angular8, the CLI Builder API is stable and available to developers who want to customize the <code>Angular CLI</code> by adding or modifying commands. For example, you could supply a builder to perform an entirely new task, or to change which third-party tool is used by an existing command.</p>\n","level":3},{"slug":"what-is-a-builder","title":"What is a builder?","answer":"<p>  A builder function ia a function that uses the <code>Architect API</code> to perform a complex process such as &quot;build&quot; or &quot;test&quot;. The builder code is defined in an npm package. For example, BrowserBuilder runs a webpack build for a browser target and KarmaBuilder starts the Karma server and runs a webpack build for unit tests.</p>\n","level":3},{"slug":"how-do-you-invoke-a-builder","title":"How do you invoke a builder?","answer":"<p>  The Angular CLI command <code>ng run</code> is used to invoke a builder with a specific target configuration. The workspace configuration file, <code>angular.json</code>, contains default configurations for built-in builders.</p>\n","level":3},{"slug":"how-do-you-create-app-shell-in-angular","title":"How do you create app shell in Angular?","answer":"<p>  An App shell is a way to render a portion of your application via a route at build time. This is useful to first paint of your application that appears quickly because the browser can render static HTML and CSS without the need to initialize JavaScript. You can achieve this using Angular CLI which generates an app shell for running server-side of your app.</p>\n<pre><code class=\"language-javascript\">ng generate appShell [options] (or)\nng g appShell [options]</code></pre>\n","level":3},{"slug":"what-are-the-case-types-in-angular","title":"What are the case types in Angular?","answer":"<p>  Angular uses capitalization conventions to distinguish the names of various types. Angular follows the list of the below case types.</p>\n<ol>\n<li><strong>camelCase :</strong> Symbols, properties, methods, pipe names, non-component directive selectors, constants uses lowercase on the first letter of the item. For example, &quot;selectedUser&quot;</li>\n<li><strong>UpperCamelCase (or PascalCase):</strong> Class names, including classes that define components, interfaces, NgModules, directives, and pipes uses uppercase on the first letter of the item.</li>\n<li><strong>dash-case (or &quot;kebab-case&quot;):</strong> The descriptive part of file names, component selectors uses dashes between the words. For example, &quot;app-user-list&quot;.</li>\n<li><strong>UPPER_UNDERSCORE_CASE:</strong> All constants uses capital letters connected with underscores. For example, &quot;NUMBER_OF_USERS&quot;.</li>\n</ol>\n","level":3},{"slug":"what-is-bazel-tool","title":"What is Bazel tool?","answer":"<p>  Bazel is a powerful build tool developed and massively used by Google and it can keep track of the dependencies between different packages and build targets. In Angular8, you can build your CLI application with Bazel.\n<strong>Note:</strong> The Angular framework itself is built with Bazel.</p>\n","level":3},{"slug":"what-are-the-advantages-of-bazel-tool","title":"What are the advantages of Bazel tool?","answer":"<p>  Below are the list of key advantages of Bazel tool,</p>\n<ol>\n<li>It creates the possibility of building your back-ends and front-ends with the same tool</li>\n<li>The incremental build and tests</li>\n<li>It creates the possibility to have remote builds and cache on a build farm.</li>\n</ol>\n","level":3},{"slug":"what-are-the-security-principles-in-angular","title":"What are the security principles in angular?","answer":"<p> Below are the list of security principles in angular,</p>\n<pre><code>    1.    You should avoid direct use of the DOM APIs.\n    2.  You should enable Content Security Policy (CSP) and configure your web server to return appropriate CSP HTTP headers.\n    3.  You should Use the offline template compiler.\n    4.  You should Use Server Side XSS protection.\n    5.  You should Use DOM Sanitizer.\n    6.  You should Preventing CSRF or XSRF attacks. </code></pre>\n<ol start=\"154\">\n<li><h3 id=\"what-is-the-reason-to-deprecate-web-tracing-framework\">What is the reason to deprecate Web Tracing Framework?</h3>\nAngular has supported the integration with the Web Tracing Framework (WTF) for the purpose of performance testing. Since it is not well maintained and failed in majority of the applications, the support is deprecated in latest releases.</li>\n</ol>\n","level":3},{"slug":"what-is-schematic","title":"What is schematic","answer":"<p> It&#39;s a scaffolding library that defines how to generate or transform a programming project by creating, modifying, refactoring, or moving files and code. It defines rules that operate on a virtual file system called a tree.</p>\n","level":3},{"slug":"what-is-rule-in-schematics","title":"What is rule in Schematics?","answer":"<p> In schematics world, it&#39;s a function that operates on a file tree to create, delete, or modify files in a specific manner.</p>\n","level":3},{"slug":"what-are-the-best-practices-for-security-in-angular","title":"What are the best practices for security in angular?","answer":"<p> Below are the best practices of security in angular,</p>\n<ol>\n<li>Use the latest Angular library releases</li>\n<li>Don&#39;t modify your copy of Angular</li>\n<li>Avoid Angular APIs marked in the documentation as “Security Risk.”</li>\n</ol>\n","level":3},{"slug":"what-is-angular-security-model-for-preventing-xss-attacks","title":"What is Angular security model for preventing XSS attacks?","answer":"<p> Angular treats all values as untrusted by default. i.e, Angular sanitizes and escapes untrusted values When a value is inserted into the DOM from a template, via property, attribute, style, class binding, or interpolation.</p>\n","level":3},{"slug":"what-are-the-various-security-contexts-in-Angular","title":"What are the various security contexts in Angular?","answer":"<p> Angular defines the following security contexts for sanitization,</p>\n<ol>\n<li><strong>HTML:</strong> It is used when interpreting a value as HTML such as binding to innerHtml.</li>\n<li><strong>Style:</strong> It is used when binding CSS into the style property.</li>\n<li><strong>URL:</strong> It is used for URL properties such as <code>&lt;a href&gt;</code>.</li>\n<li><strong>Resource URL:</strong> It is a URL that will be loaded and executed as code such as <code>&lt;script src&gt;</code>.</li>\n</ol>\n","level":3},{"slug":"is-safe-to-use-direct-dom-api-methods-in-terms-of-security","title":"Is safe to use direct DOM API methods in terms of security?","answer":"<p> No,the built-in browser DOM APIs or methods don&#39;t automatically protect you from security vulnerabilities. In this case it is recommended to use Angular templates instead of directly interacting with DOM. If it is unavoidable then use the built-in Angular sanitization functions.</p>\n","level":3},{"slug":"what-is-dom-sanitizer","title":"What is DOM sanitizer?","answer":"<p> <code>DomSanitizer</code> is used to help preventing Cross Site Scripting Security bugs (XSS) by sanitizing values to be safe to use in the different DOM contexts.</p>\n","level":3},{"slug":"how-do-you-support-server-side-xss-protection-in-angular-application","title":"How do you support server side XSS protection in Angular application?","answer":"<p> The server-side XSS protection is supported in an angular application by using a templating language that automatically escapes values to prevent XSS vulnerabilities on the server. But don&#39;t use a templating language to generate Angular templates on the server side which creates a high risk of introducing template-injection vulnerabilities.</p>\n","level":3},{"slug":"is-angular-prevents-http-level-vulnerabilities","title":"Does angular prevent http level vulnerabilities?","answer":"<p> Angular has built-in support for preventing http level vulnerabilities such as as cross-site request forgery (CSRF or XSRF) and cross-site script inclusion (XSSI). Even though these vulnerabilities need to be mitigated on server-side, Angular provides helpers to make the integration easier on the client side.</p>\n<ol>\n<li>HttpClient supports a token mechanism used to prevent XSRF attacks</li>\n<li>HttpClient library recognizes the convention of prefixed JSON responses(which non-executable js code with &quot;)]}&#39;,\\n&quot; characters) and automatically strips the string &quot;)]}&#39;,\\n&quot; from all responses before further parsing</li>\n</ol>\n","level":3},{"slug":"what-is-testbed","title":"What is TestBed?","answer":"<p> TestBed is an api for writing unit tests for Angular applications and it&#39;s libraries. Even though We still write our tests in Jasmine and run using Karma, this API provides an easier way to create components, handle injection, test asynchronous behaviour and interact with our application.</p>\n","level":3},{"slug":"what-is-protractor","title":"What is protractor?","answer":"<p> Protractor is an end-to-end test framework for Angular and AngularJS applications. It runs tests against your application running in a real browser, interacting with it as a user would.</p>\n<pre><code class=\"language-javascript\">npm install -g protractor</code></pre>\n","level":3},{"slug":"how-do-you-create-schematics-for-libraries","title":"How do you create schematics for libraries?","answer":"<p> You can create your own schematic collections to integrate your library with the Angular CLI. These collections are classified as 3 main schematics,</p>\n<ol>\n<li><strong>Add schematics:</strong> These schematics are used to install library in an Angular workspace using <code>ng add</code> command.\nFor example, @angular/material schematic tells the add command to install and set up Angular Material and theming.</li>\n<li><strong>Generate schematics</strong>: These schematics are used to modify projects, add configurations and scripts, and scaffold artifacts in library using <code>ng generate</code> command.\nFor example, @angular/material generation schematic supplies generation schematics for the UI components. Let&#39;s say the table component is generated using <code>ng generate @angular/material:table </code>.</li>\n<li><strong>Update schematics:</strong> These schematics are used to update library&#39;s dependencies and adjust for breaking changes in a new library release using <code>ng update</code> command.\nFor example, @angular/material update schematic updates material and cdk dependencies using <code>ng update @angular/material</code> command.</li>\n</ol>\n","level":3},{"slug":"what-is-the-reason-for-no-provider-for-http-exception","title":"What is the reason for No provider for HTTP exception?","answer":"<p> This exception is due to missing HttpClientModule in your module. You just need to import in module as below,</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { HttpClientModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/http&#x27;</span>;\n@NgModule({\n<span class=\"hljs-attr\">imports</span>: [\nBrowserModule,\nHttpClientModule,\n],\n<span class=\"hljs-attr\">declarations</span>: [ AppComponent ],\n<span class=\"hljs-attr\">bootstrap</span>:    [ AppComponent ]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{ }</code></pre>\n","level":3},{"slug":"is-mandatory-to-pass-static-flag-for-viewchild","title":"Is mandatory to pass static flag for ViewChild?","answer":"<p> In Angular 8, the static flag is required for ViewChild. Whereas in Angular9, you no longer need to pass this property. Once you updated to Angular9 using <code>ng update</code>, the migration will remove { static: false } script everywhere.</p>\n<pre><code class=\"language-javascript\">@ViewChild(ChildDirective) child: ChildDirective; <span class=\"hljs-comment\">// Angular9 usage</span>\n@ViewChild(ChildDirective, { <span class=\"hljs-attr\">static</span>: <span class=\"hljs-literal\">false</span> }) child: ChildDirective; <span class=\"hljs-comment\">//Angular8 usage</span></code></pre>\n","level":3},{"slug":"what-is-the-precedence-between-pipe-and-ternary-operators","title":"What is the precedence between pipe and ternary operators?","answer":"<p> The pipe operator has a higher precedence than the ternary operator (?:). For example, the expression <code>first ? second : third | fourth</code> is parsed as <code>first ? second : (third | fourth)</code>.</p>\n","level":3},{"slug":"how-do-you-manually-bootstrap-an-application","title":"How do you manually bootstrap an application?","answer":"<p> You can use <code>ngDoBootstrap</code> hook for a manual bootstrapping of the application instead of using bootstrap array in <code>@NgModule</code> annotation. This hook is part of <code>DoBootstap</code> interface.</p>\n<pre><code class=\"language-js\">interface DoBootstrap {\nngDoBootstrap(appRef: ApplicationRef): <span class=\"hljs-keyword\">void</span>\n}</code></pre>\n<p>The module needs to be implement the above interface to use the hook for bootstrapping.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">DoBootstrap</span> </span>{\n<span class=\"hljs-function\"><span class=\"hljs-title\">ngDoBootstrap</span>(<span class=\"hljs-params\">appRef: ApplicationRef</span>)</span> {\nappRef.bootstrap(AppComponent); <span class=\"hljs-comment\">// bootstrapped entry component need to be passed</span>\n}\n}</code></pre>\n","level":3},{"slug":"is-it-necessary-for-bootstrapped-component-to-be-entry-component","title":"Is it necessary for bootstrapped component to be entry component?","answer":"<p> Yes, the bootstrapped component needs to be an entry component. This is because the bootstrapping process is an imperative process.</p>\n","level":3},{"slug":"why-is-not-necessary-to-use-entrycomponents-array-every-time","title":"Why is not necessary to use entryComponents array every time?","answer":"<p> Most of the time, you don&#39;t need to explicity to set entry components in entryComponents array of ngModule decorator. Because angular adds components from both @NgModule.bootstrap and route definitions to entry components automatically.</p>\n","level":3},{"slug":"what-is-the-role-of-ngmodule-metadata-in-compilation-process","title":"What is the role of ngModule metadata in compilation process?","answer":"<p> The <code>@NgModule</code> metadata is used to tell the Angular compiler what components to be compiled for this module and how to link this module with other modules.</p>\n","level":3},{"slug":"how-does-angular-finds-components-directives-and-pipes","title":"How does angular finds components, directives and pipes?","answer":"<p> The Angular compiler finds a component or directive in a template when it can match the selector of that component or directive in that template. Whereas it finds a pipe if the pipe&#39;s name appears within the pipe syntax of the template HTML.</p>\n","level":3},{"slug":"what-are-feature-modules","title":"What are feature modules?","answer":"<p> Feature modules are NgModules, which are used for the purpose of organizing code. The feature module can be created with Angular CLI using the below command in the root directory,</p>\n<pre><code class=\"language-javascript\">ng generate <span class=\"hljs-built_in\">module</span> MyCustomFeature <span class=\"hljs-comment\">//</span></code></pre>\n<p>Angular CLI creates a folder called <code>my-custom-feature</code> with a file inside called <code>my-custom-feature.module.ts</code> with the following contents</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { NgModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { CommonModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n@NgModule({\n<span class=\"hljs-attr\">imports</span>: [\nCommonModule\n],\n<span class=\"hljs-attr\">declarations</span>: []\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCustomFeature</span> </span>{ }</code></pre>\n<p><strong>Note:</strong>  The &quot;Module&quot; suffix shouldn&#39;t present in the name because the CLI appends it.</p>\n","level":3},{"slug":"what-are-the-steps-to-use-declaration-elements","title":"What are the steps to use declaration elements?","answer":"<p> Below are the steps to be followed to use declaration elements.</p>\n<ol>\n<li>Create the element(component, directive and pipes) and export it from the file where you wrote it</li>\n<li>Import it into the appropriate module.</li>\n<li>Declare it in the @NgModule declarations array.</li>\n</ol>\n","level":3},{"slug":"what-happens-if-browsermodule-used-in-feature-module","title":"What happens if browserModule used in feature module?","answer":"<p> If you do import <code>BrowserModule</code> into a lazy loaded feature module, Angular returns an error telling you to use <code>CommonModule</code> instead. Because BrowserModule’s providers are for the entire app so it should only be in the root module, not in feature module. Whereas Feature modules only need the common directives in CommonModule.</p>\n","level":3},{"slug":"what-are-the-types-of-feature-modules","title":"What are the types of feature modules?","answer":"<p> Below are the five categories of feature modules,</p>\n<ol>\n<li><strong>Domain:</strong> Deliver a user experience dedicated to a particular application domain(For example, place an order, registration etc)</li>\n<li><strong>Routed:</strong> These are domain feature modules whose top components are the targets of router navigation routes.</li>\n<li><strong>Routing:</strong> It provides routing configuration for another module.</li>\n<li><strong>Service:</strong> It provides utility services such as data access and messaging(For example, HttpClientModule)</li>\n<li><strong>Widget:</strong> It makes components, directives, and pipes available to external modules(For example, third-party libraries such as Material UI)</li>\n</ol>\n","level":3},{"slug":"what-is-the-recommendation-for-provider-scope","title":"What is the recommendation for provider scope?","answer":"<p> You should always provide your service in the root injector unless there is a case where you want the service to be available only if you import a particular @NgModule.</p>\n","level":3},{"slug":"how-do-you-restrict-provider-scope-to-a-module","title":"How do you restrict provider scope to a module?","answer":"<p> It is possible to restrict service provider scope to a specific module instead making available to entire application. There are two possible ways to do it.</p>\n<ol>\n<li><strong>Using providedIn in service:</strong><pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { Injectable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { SomeModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./some.module&#x27;</span>;\n@Injectable({\n<span class=\"hljs-attr\">providedIn</span>: SomeModule,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeService</span> </span>{\n}</code></pre>\n</li>\n<li><strong>Declare provider for the service in module:</strong><pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { NgModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { SomeService } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./some.service&#x27;</span>;\n@NgModule({\n<span class=\"hljs-attr\">providers</span>: [SomeService],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SomeModule</span> </span>{\n}</code></pre>\n</li>\n</ol>\n","level":3},{"slug":"how-do-you-provide-a-singleton-service","title":"How do you provide a singleton service?","answer":"<p> There are two possible ways to provide a singleton service.</p>\n<ol>\n<li>Set the providedIn property of the @Injectable() to &quot;root&quot;. This is the preferred way(starting from Angular 6.0) of creating a singleton service since it makes your services tree-shakable.<pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { Injectable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n@Injectable({\n<span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>,\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyService</span> </span>{\n}</code></pre>\n</li>\n<li>Include the service in root module or in a module that is only imported by root module. It has been used to register services before Angular 6.0.<pre><code class=\"language-js\">@NgModule({\n...\n<span class=\"hljs-attr\">providers</span>: [MyService],\n...\n})</code></pre>\n</li>\n</ol>\n","level":3},{"slug":"what-are-the-different-ways-to-remove-duplicate-service-registration","title":"What are the different ways to remove duplicate service registration?","answer":"<p> If a module defines provides and declarations then loading the module in multiple feature modules will duplicate the registration of the service. Below are the different ways to prevent this duplicate behavior.</p>\n<ol>\n<li>Use the providedIn syntax instead of registering the service in the module.</li>\n<li>Separate your services into their own module.</li>\n<li>Define forRoot() and forChild() methods in the module.</li>\n</ol>\n","level":3},{"slug":"how-does-forroot-method-helpful-to-avoid-duplicate-router-instances","title":"How does forRoot method helpful to avoid duplicate router instances?","answer":"<p> If the <code>RouterModule</code> module didn’t have forRoot() static method then each feature module would instantiate a new Router instance, which leads to broken application due to duplicate instances. After using forRoot() method, the root application module imports <code>RouterModule.forRoot(...)</code> and gets a Router, and all feature modules import <code>RouterModule.forChild(...)</code> which does not instantiate another Router.</p>\n","level":3},{"slug":"what-is-a-shared-module","title":"What is a shared module?","answer":"<p> The Shared Module is the module in which you put commonly used directives, pipes, and components into one module that is shared(import it) throughout the application.\nFor example, the below shared module imports CommonModule, FormsModule for common directives and components, pipes and directives based on the need,</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { CommonModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { NgModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { FormsModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { UserComponent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./user.component&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { NewUserDirective } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./new-user.directive&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { OrdersPipe } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./orders.pipe&#x27;</span>;\n@NgModule({\n<span class=\"hljs-attr\">imports</span>:      [ CommonModule ],\n<span class=\"hljs-attr\">declarations</span>: [ UserComponent, NewUserDirective, OrdersPipe ],\n<span class=\"hljs-attr\">exports</span>:      [ UserComponent, NewUserDirective, OrdersPipe,\nCommonModule, FormsModule ]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SharedModule</span> </span>{ }</code></pre>\n","level":3},{"slug":"can-i-share-services-using-modules","title":"Can I share services using modules?","answer":"<p> No, it is not recommended to share services by importing module. i.e Import modules when you want to use directives, pipes, and components only. The best approach to get a hold of shared services is through &#39;Angular dependency injection&#39; because importing a module will result in a new service instance.</p>\n","level":3},{"slug":"how-do-you-get-current-direction-for-locales","title":"How do you get current direction for locales??","answer":"<p> In Angular 9.1, the API method <code>getLocaleDirection</code> can be used to get the current direction in your app. This method is useful to support Right to Left locales for your Internationalization based applications.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { getLocaleDirection, registerLocaleData } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { LOCALE_ID } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> localeAr <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/common/locales/ar&#x27;</span>;\n...\n<span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">@Inject(LOCALE_ID) locale</span>)</span> {\n<span class=\"hljs-keyword\">const</span> directionForLocale = getLocaleDirection(locale); <span class=\"hljs-comment\">// Returns &#x27;rtl&#x27; or &#x27;ltr&#x27; based on the current locale</span>\nregisterLocaleData(localeAr, <span class=\"hljs-string\">&#x27;ar-ae&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> direction = getLocaleDirection(<span class=\"hljs-string\">&#x27;ar-ae&#x27;</span>); <span class=\"hljs-comment\">// Returns &#x27;rtl&#x27;</span>\n<span class=\"hljs-comment\">// Current direction is used to provide conditional logic here</span>\n}</code></pre>\n","level":3},{"slug":"what-is-ngcc","title":"What is ngcc?","answer":"<p> The ngcc(Angular Compatibility Compiler) is a tool which upgrades node_module compiled with non-ivy ngc into ivy compliant format. The <code>postinstall</code> script from package.json will make sure your node_modules will be compatible with the Ivy renderer.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-string\">&quot;scripts&quot;</span>: {\n<span class=\"hljs-string\">&quot;postinstall&quot;</span>: <span class=\"hljs-string\">&quot;ngcc&quot;</span>\n}</code></pre>\n<p>Whereas, Ivy compiler (ngtsc), which compiles Ivy-compatible code.</p>\n","level":3},{"slug":"what-classes-should-not-be-added-to-declarations","title":"What classes should not be added to declarations?","answer":"<p> The below class types shouldn&#39;t be added to declarations</p>\n<ol>\n<li>A class which is already declared in any another module.</li>\n<li>Directives imported from another module.</li>\n<li>Module classes.</li>\n<li>Service classes.</li>\n<li>Non-Angular classes and objects, such as strings, numbers, functions, entity models, configurations, business logic, and helper classes.</li>\n</ol>\n","level":3},{"slug":"what-is-noopzone","title":"What is NoopZone?","answer":"<p> Zone is loaded/required by default in Angular applications and it helps Angular to know when to trigger the change detection. This way, it make sures developers focus on application development rather core part of Angular. You can also use Angular without Zone but the change detection need to be implemented on your own and <code>noop zone</code> need to be configured in bootstrap process.\nLet&#39;s follow the below two steps to remove zone.js,</p>\n<ol>\n<li>Remove the zone.js import from polyfills.ts.\n```js\n/*<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></li>\n</ol>\n<ul>\n<li>Zone JS is required by default for Angular itself.</li>\n<li>/\n// import &#39;zone.js/dist/zone&#39;;  // Included with Angular CLI.\n```</li>\n</ul>\n<ol start=\"2\">\n<li>Bootstrap Angular with noop zone in src/main.ts.<pre><code class=\"language-js\">platformBrowserDynamic().bootstrapModule(AppModule, {<span class=\"hljs-attr\">ngZone</span>: <span class=\"hljs-string\">&#x27;noop&#x27;</span>})\n.catch(<span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.error(err));</code></pre>\n</li>\n</ol>\n","level":3},{"slug":"what-is-a-zone-context","title":"What is a zone context?","answer":"<p>  Execution Context is an abstract concept that holds information about the environment within the current code being executed. A zone provides an execution context that persists across asynchronous operations is called as zone context. For example, the zone context will be same in both outside and inside setTimeout callback function,</p>\n<pre><code class=\"language-js\">zone.run(<span class=\"hljs-function\">() =&gt;</span> {\n<span class=\"hljs-comment\">// outside zone</span>\nexpect(zoneThis).toBe(zone);\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-comment\">// the same outside zone exist here</span>\nexpect(zoneThis).toBe(zone);\n});\n});</code></pre>\n<p>The current zone is retrieved through <code>Zone.current</code>.</p>\n","level":3},{"slug":"what-are-the-lifecycle-hooks-of-a-zone","title":"What are the lifecycle hooks of a zone?","answer":"<p> There are four lifecycle hooks for asynchronous operations from zone.js.</p>\n<ol>\n<li><strong>onScheduleTask:</strong> This hook triggers when a new asynchronous task is scheduled. For example, when you call setTimeout()<pre><code class=\"language-js\">onScheduleTask: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">delegate, curr, target, task</span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;new task is scheduled:&#x27;</span>, task.type, task.source);\n<span class=\"hljs-keyword\">return</span> delegate.scheduleTask(target, task);\n}</code></pre>\n</li>\n<li><strong>onInvokeTask:</strong> This hook triggers when an asynchronous task is about to execute. For example, when the callback of setTimeout() is about to execute.<pre><code class=\"language-js\">onInvokeTask: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">delegate, curr, target, task, applyThis, applyArgs</span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;task will be invoked:&#x27;</span>, task.type, task.source);\n<span class=\"hljs-keyword\">return</span> delegate.invokeTask(target, task, applyThis, applyArgs);\n}</code></pre>\n</li>\n<li><strong>onHasTask:</strong> This hook triggers when the status of one kind of task inside a zone changes from stable(no tasks in the zone) to unstable(a new task is scheduled in the zone) or from unstable to stable.<pre><code class=\"language-js\">onHasTask: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">delegate, curr, target, hasTaskState</span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;task state changed in the zone:&#x27;</span>, hasTaskState);\n<span class=\"hljs-keyword\">return</span> delegate.hasTask(target, hasTaskState);\n}</code></pre>\n</li>\n<li><strong>onInvoke:</strong> This hook triggers when a synchronous function is going to execute in the zone.<pre><code class=\"language-js\">onInvoke: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">delegate, curr, target, callback, applyThis, applyArgs</span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;the callback will be invoked:&#x27;</span>, callback);\n<span class=\"hljs-keyword\">return</span> delegate.invoke(target, callback, applyThis, applyArgs);\n}</code></pre>\n</li>\n</ol>\n","level":3},{"slug":"which-are-the-methods-of-ngzone-used-to-control-change-detection","title":"What are the methods of NgZone used to control change detection?","answer":"<p> NgZone service provides a <code>run()</code> method that allows you to execute a function inside the angular zone. This function is used to execute third party APIs which are not handled by Zone and trigger change detection automatically at the correct time.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> </span>{\n<span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">private ngZone: NgZone</span>)</span> {}\n<span class=\"hljs-function\"><span class=\"hljs-title\">ngOnInit</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"hljs-comment\">// use ngZone.run() to make the asynchronous operation in the angular zone</span>\n<span class=\"hljs-built_in\">this</span>.ngZone.run(<span class=\"hljs-function\">() =&gt;</span> {\nsomeNewAsyncAPI(<span class=\"hljs-function\">() =&gt;</span> {\n<span class=\"hljs-comment\">// update the data of the component</span>\n});\n});\n}\n}</code></pre>\n<p>Whereas <code>runOutsideAngular()</code> method is used when you don&#39;t want to trigger change detection.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppComponent</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">OnInit</span> </span>{\n<span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">private ngZone: NgZone</span>)</span> {}\n<span class=\"hljs-function\"><span class=\"hljs-title\">ngOnInit</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"hljs-comment\">// Use this method when you know no data will be updated</span>\n<span class=\"hljs-built_in\">this</span>.ngZone.runOutsideAngular(<span class=\"hljs-function\">() =&gt;</span> {\n<span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> {\n<span class=\"hljs-comment\">// update component data and don&#x27;t trigger change detection</span>\n});\n});\n}\n}</code></pre>\n","level":3},{"slug":"what-is-an-optional-dependency","title":"What is an optional dependency?","answer":"<p> The optional dependency is a parameter decorator to be used on constructor parameters, which marks the parameter as being an optional dependency. Due to this, the DI framework provides null if the dependency is not found.\nFor example, If you don&#39;t register a logger provider anywhere, the injector sets the value of logger(or logger service) to null in the below class.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { Optional } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">@Optional() private logger?: Logger</span>)</span> {\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.logger) {\n<span class=\"hljs-built_in\">this</span>.logger.log(<span class=\"hljs-string\">&#x27;This is an optional dependency message&#x27;</span>);\n} <span class=\"hljs-keyword\">else</span> {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;The logger is not registered&#x27;</span>);\n}\n}</code></pre>\n","level":3},{"slug":"what-are-the-state-css-classes-provided-by-ngmodel","title":"What are the state CSS classes provided by ngModel?","answer":"<p> The ngModel directive updates the form control with special Angular CSS classes to reflect it&#39;s state. Let&#39;s find the list of classes in a tabular format,\n| Form control state | If true | If false |\n|---- | --------- | --- |\n| Visited | ng-touched | ng-untouched |\n| Value has changed | ng-dirty     | ng-pristine |\n| Value is valid|     ng-valid | ng-invalid |</p>\n","level":3},{"slug":"what-are-the-types-of-validator-functions","title":"What are the types of validator functions?","answer":"<p> In reactive forms, the validators can be either synchronous or asynchronous functions,</p>\n<ol>\n<li><strong>Sync validators:</strong> These are the synchronous functions which take a control instance and immediately return either a set of validation errors or null. Also, these functions passed as second argument while instantiating the form control. The main use cases are simple checks like whether a field is empty, whether it exceeds a maximum length etc.</li>\n<li><strong>Async validators:</strong> These are the asynchronous functions which take a control instance and return a Promise or Observable that later emits a set of validation errors or null. Also, these functions passed as second argument while instantiating the form control. The main use cases are complex validations like hitting a server to check the availability of a username or email.\nThe representation of these validators looks like below<pre><code class=\"language-js\"><span class=\"hljs-built_in\">this</span>.myForm = formBuilder.group({\n<span class=\"hljs-attr\">firstName</span>: [<span class=\"hljs-string\">&#x27;value&#x27;</span>],\n<span class=\"hljs-attr\">lastName</span>: [<span class=\"hljs-string\">&#x27;value&#x27;</span>, *Some Sync validation <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*],\n<span class=\"hljs-title\">email</span>: [&#x27;<span class=\"hljs-title\">value</span>&#x27;, *<span class=\"hljs-title\">Some</span> <span class=\"hljs-title\">validation</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*, *<span class=\"hljs-title\">Some</span> <span class=\"hljs-title\">asynchronous</span> <span class=\"hljs-title\">validation</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*]\n})</span>;</span></span></code></pre>\n</li>\n</ol>\n","level":3},{"slug":"how-do-you-optimize-the-performance-of-async-validators","title":"How do you optimize the performance of async validators?","answer":"<p> Since all validators run after every form value change, it creates a major impact on performance with async validators by hitting the external API on each keystroke. This situation can be avoided by delaying the form validity by changing the updateOn property from change (default) to submit or blur.\nThe usage would be different based on form types,</p>\n<ol>\n<li><strong>Template-driven forms:</strong> Set the property on <code>ngModelOptions</code> directive<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> [(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;name&quot;</span> [<span class=\"hljs-attr\">ngModelOptions</span>]=<span class=\"hljs-string\">&quot;{updateOn: &#x27;blur&#x27;}&quot;</span>&gt;</span></code></pre>\n</li>\n<li><strong>Reactive-forms:</strong> Set the property on FormControl instance<pre><code class=\"language-js\">name = <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>, {<span class=\"hljs-attr\">updateOn</span>: <span class=\"hljs-string\">&#x27;blur&#x27;</span>});</code></pre>\n</li>\n</ol>\n","level":3}],"tabs":[{"label":"Junior","slug":"junior","link":"/topics/angular/1"},{"label":"Middle","slug":"middle","link":"/topics/angular/2"},{"label":"Senior","slug":"senior","link":"/topics/angular/3"}],"title":"Questions","topic":{"image":"/img/topics/angular.svg","slug":"angular","label":"Angular"}},"__N_SSG":true}