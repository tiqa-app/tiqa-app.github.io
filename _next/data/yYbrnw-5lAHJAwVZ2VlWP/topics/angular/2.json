{"pageProps":{"activeTab":"middle","back":"/topics","questions":[{"slug":"how-do-you-categorize-data-binding-types","title":"How do you categorize data binding types?","answer":"<p> Binding types can be grouped into three categories distinguished by the direction of data flow. They are listed as below,</p>\n<ol>\n<li>From the source-to-view</li>\n<li>From view-to-source</li>\n<li>View-to-source-to-view\nThe possible binding syntax can be tabularized as below,<table>\n<thead>\n<tr>\n<th>Data direction</th>\n<th>Syntax</th>\n<th>Type</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>From the source-to-view(One-way)</td>\n<td>1. {{expression}} 2. [target]=&quot;expression&quot; 3. bind-target=&quot;expression&quot;</td>\n<td>Interpolation, Property, Attribute, Class, Style</td>\n</tr>\n<tr>\n<td>From view-to-source(One-way)</td>\n<td>1. (target)=&quot;statement&quot; 2. on-target=&quot;statement&quot;</td>\n<td>Event</td>\n</tr>\n<tr>\n<td>View-to-source-to-view(Two-way)</td>\n<td>1. [(target)]=&quot;expression&quot; 2. bindon-target=&quot;expression&quot;</td>\n<td>Two-way</td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n","level":2},{"slug":"what-is-the-difference-between-pure-and-impure-pipe","title":"What is the difference between pure and impure pipe?","answer":"<p>A pure pipe is only called when Angular detects a change in the value or the parameters passed to a pipe. For example, any changes to a primitive input value (String, Number, Boolean, Symbol) or a changed object reference (Date, Array, Function, Object). An impure pipe is called for every change detection cycle no matter whether the value or parameters changes. i.e, An impure pipe is called often, as often as every keystroke or mouse-move.</p>\n","level":2},{"slug":"what-is-the-difference-between-promise-and-observable","title":"What is the difference between promise and observable?","answer":"<p>Below are the list of differences between promise and observable,</p>\n<table>\n<thead>\n<tr>\n<th>Observable</th>\n<th>Promise</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Declarative: Computation does not start until subscription so that they can be run whenever you need the result</td>\n<td>Execute immediately on creation</td>\n</tr>\n<tr>\n<td>Provide multiple values over time</td>\n<td>Provide only one</td>\n</tr>\n<tr>\n<td>Subscribe method is used for error handling which makes centralized and predictable error handling</td>\n<td>Push errors to the child promises</td>\n</tr>\n<tr>\n<td>Provides chaining and subscription to handle complex applications</td>\n<td>Uses only .then() clause</td>\n</tr>\n</tbody></table>","level":2},{"slug":"what-are-the-utility-functions-provided-by-rxjs","title":"What are the utility functions provided by RxJS?","answer":"<p>The RxJS library also provides below utility functions for creating and working with observables.</p>\n<ol>\n<li>Converting existing code for async operations into observables</li>\n<li>Iterating through the values in a stream</li>\n<li>Mapping values to different types</li>\n<li>Filtering streams</li>\n<li>Composing multiple streams</li>\n</ol>\n","level":2},{"slug":"what-are-observable-creation-functions","title":"What are observable creation functions?","answer":"<p>RxJS provides creation functions for the process of creating observables from things such as promises, events, timers and Ajax requests. Let us explain each of them with an example,</p>\n<ol>\n<li>Create an observable from a promise<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { <span class=\"hljs-keyword\">from</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rxjs&#x27;</span>; <span class=\"hljs-comment\">// from function</span>\n<span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">from</span>(fetch(<span class=\"hljs-string\">&#x27;/api/endpoint&#x27;</span>)); <span class=\"hljs-comment\">//Created from Promise</span>\ndata.subscribe({\n<span class=\"hljs-function\"><span class=\"hljs-title\">next</span>(<span class=\"hljs-params\">response</span>)</span> { <span class=\"hljs-built_in\">console</span>.log(response); },\n<span class=\"hljs-function\"><span class=\"hljs-title\">error</span>(<span class=\"hljs-params\">err</span>)</span> { <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&#x27;Error: &#x27;</span> + err); },\n<span class=\"hljs-function\"><span class=\"hljs-title\">complete</span>(<span class=\"hljs-params\"></span>)</span> { <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;Completed&#x27;</span>); }\n});</code></pre>\n</li>\n<li>Create an observable that creates an AJAX request<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { ajax } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rxjs/ajax&#x27;</span>; <span class=\"hljs-comment\">// ajax function</span>\n<span class=\"hljs-keyword\">const</span> apiData = ajax(<span class=\"hljs-string\">&#x27;/api/data&#x27;</span>); <span class=\"hljs-comment\">// Created from AJAX request</span>\n<span class=\"hljs-comment\">// Subscribe to create the request</span>\napiData.subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> <span class=\"hljs-built_in\">console</span>.log(res.status, res.response));</code></pre>\n</li>\n<li>Create an observable from a counter<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { interval } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rxjs&#x27;</span>; <span class=\"hljs-comment\">// interval function</span>\n<span class=\"hljs-keyword\">const</span> secondsCounter = interval(<span class=\"hljs-number\">1000</span>); <span class=\"hljs-comment\">// Created from Counter value</span>\nsecondsCounter.subscribe(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span>\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Counter value: <span class=\"hljs-subst\">${n}</span>`</span>));</code></pre>\n</li>\n<li>Create an observable from an event<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { fromEvent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;rxjs&#x27;</span>;\n<span class=\"hljs-keyword\">const</span> el = <span class=\"hljs-built_in\">document</span>.getElementById(<span class=\"hljs-string\">&#x27;custom-element&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> mouseMoves = fromEvent(el, <span class=\"hljs-string\">&#x27;mousemove&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> subscription = mouseMoves.subscribe(<span class=\"hljs-function\">(<span class=\"hljs-params\">e: MouseEvent</span>) =&gt;</span> {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Coordnitaes of mouse pointer: <span class=\"hljs-subst\">${e.clientX}</span> * <span class=\"hljs-subst\">${e.clientY}</span>`</span>);\n});</code></pre>\n</li>\n</ol>\n","level":2},{"slug":"what-is-the-browser-support-of-angular-elements","title":"What is the browser support of Angular Elements?","answer":"<p>Since Angular elements are packaged as custom elements the browser support of angular elements is same as custom elements support.\nThis feature is is currently supported natively in a number of browsers and pending for other browsers.\n| Browser | Angular Element Support |\n|---- | --------- |\n| Chrome | Natively supported|\n| Opera | Natively supported |\n| Safari| Natively supported |\n| Firefox | Natively supported from 63 version onwards. You need to enable dom.webcomponents.enabled and dom.webcomponents.customelements.enabled in older browsers |\n| Edge| Currently it is in progress|</p>\n","level":2},{"slug":"what-are-custom-elements","title":"What are custom elements?","answer":"<p>Custom elements (or Web Components) are a Web Platform feature which extends HTML by allowing you to define a tag whose content is created and controlled by JavaScript code. The browser maintains a <code>CustomElementRegistry</code> of defined custom elements, which maps an instantiable JavaScript class to an HTML tag. Currently this feature is supported by Chrome, Firefox, Opera, and Safari, and available in other browsers through polyfills.</p>\n","level":2},{"slug":"do-i-need-to-bootstrap-custom-elements","title":"Do I need to bootstrap custom elements?","answer":"<p>No, custom elements bootstrap (or start) automatically when they are added to the DOM, and are automatically destroyed when removed from the DOM. Once a custom element is added to the DOM for any page, it looks and behaves like any other HTML element, and does not require any special knowledge of Angular.</p>\n","level":2},{"slug":"how-do-you-create-directives-using-cli","title":"How do you create directives using CLI?","answer":"<p>You can use CLI command <code>ng generate directive</code> to create the directive class file. It creates the source file(<code>src/app/components/directivename.directive.ts</code>), the respective test file(.spec.ts) and declare the directive class file in root module.</p>\n","level":2},{"slug":"what-is-angular-universal","title":"What is Angular Universal?","answer":"<p>Angular Universal is a server-side rendering module for Angular applications in various scenarios. This is a community driven project and available under @angular/platform-server package. Recently Angular Universal is integrated with Angular CLI.</p>\n","level":2},{"slug":"what-are-different-types-of-compilation-in-angular","title":"What are different types of compilation in Angular?","answer":"<p>Angular offers two ways to compile your application,</p>\n<ol>\n<li>Just-in-Time (JIT)</li>\n<li>Ahead-of-Time (AOT)</li>\n</ol>\n","level":2},{"slug":"what-is-jit","title":"What is JIT?","answer":"<p>Just-in-Time (JIT) is a type of compilation that compiles your app in the browser at runtime. JIT compilation is the default when you run the ng build (build only) or ng serve (build and serve locally) CLI commands. i.e, the below commands used for JIT compilation,</p>\n<pre><code class=\"language-cmd\">ng build\nng serve</code></pre>\n","level":2},{"slug":"what-is-aot","title":"What is AOT?","answer":"<p>Ahead-of-Time (AOT) is a type of compilation that compiles your app at build time. For AOT compilation, include the <code>--aot</code> option with the ng build or ng serve command as below,</p>\n<pre><code class=\"language-cmd\">ng build --aot\nng serve --aot</code></pre>\n<p><strong>Note:</strong> The ng build command with the --prod meta-flag (<code>ng build --prod</code>) compiles with AOT by default.</p>\n","level":2},{"slug":"why-do-we-need-compilation-process","title":"Why do we need compilation process?","answer":"<p>The Angular components and templates cannot be understood by the browser directly. Due to that Angular applications require a compilation process before they can run in a browser. For example, In AOT compilation, both Angular HTML and TypeScript code converted into efficient JavaScript code during the build phase before browser runs it.</p>\n","level":2},{"slug":"what-are-the-advantages-with-aot","title":"What are the advantages with AOT?","answer":"<p>Below are the list of AOT benefits,</p>\n<ol>\n<li><strong>Faster rendering:</strong> The browser downloads a pre-compiled version of the application. So it can render the application immediately without compiling the app.</li>\n<li><strong>Fewer asynchronous requests:</strong> It inlines external HTML templates and CSS style sheets within the application javascript which eliminates separate ajax requests.</li>\n<li><strong>Smaller Angular framework download size:</strong> Doesn&#39;t require downloading the Angular compiler. Hence it dramatically reduces the application payload.</li>\n<li><strong>Detect template errors earlier:</strong> Detects and reports template binding errors during the build step itself</li>\n<li><strong>Better security:</strong> It compiles HTML templates and components into JavaScript.  So there won&#39;t be any injection attacks.</li>\n</ol>\n","level":2},{"slug":"what-is-codelyzer","title":"What is codelyzer?","answer":"<p> Codelyzer provides set of tslint rules for static code analysis of Angular TypeScript projects. ou can run the static code analyzer over web apps, NativeScript, Ionic etc. Angular CLI has support for this and it can be use as below,</p>\n<pre><code class=\"language-bash\">ng new codelyzer\nng lint</code></pre>\n","level":2},{"slug":"what-is-angular-animation","title":"What is angular animation?","answer":"<p> Angular&#39;s animation system is built on CSS functionality in order to animate any property that the browser considers animatable. These properties includes positions, sizes, transforms, colors, borders etc. The Angular modules for animations are <strong>@angular/animations</strong> and <strong>@angular/platform-browser</strong> and these dependencies are automatically added to your project when you create a project using Angular CLI.</p>\n","level":2},{"slug":"what-is-a-service-worker-and-its-role-in-angular","title":"What is a service worker and its role in Angular?","answer":"<p>  A service worker is a script that runs in the web browser and manages caching for an application. Starting from 5.0.0 version, Angular ships with a service worker implementation. Angular service worker is designed to optimize the end user experience of using an application over a slow or unreliable network connection, while also minimizing the risks of serving outdated content.</p>\n","level":2},{"slug":"what-are-the-design-goals-of-service-workers","title":"What are the design goals of service workers?","answer":"<p>  Below are the list of design goals of Angular&#39;s service workers,</p>\n<ol>\n<li>It caches an application just like installing a native application</li>\n<li>A running application continues to run with the same version of all files without any incompatible files</li>\n<li>When you refresh the application, it loads the latest fully cached version</li>\n<li>When changes are published then it immediately updates in the background</li>\n<li>Service workers saves the bandwidth by downloading the resources only when they changed.</li>\n</ol>\n","level":2},{"slug":"what-is-a-di-token","title":"What is a DI token?","answer":"<p>  A DI token is a lookup token associated with a dependency provider in dependency injection system. The injector maintains an internal token-provider map that it references when asked for a dependency and the DI token is the key to the map. Let&#39;s take example of DI Token usage,</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> BASE_URL = <span class=\"hljs-keyword\">new</span> InjectionToken&lt;string&gt;(<span class=\"hljs-string\">&#x27;BaseUrl&#x27;</span>);\n<span class=\"hljs-keyword\">const</span> injector =\nInjector.create({<span class=\"hljs-attr\">providers</span>: [{<span class=\"hljs-attr\">provide</span>: BASE_URL, <span class=\"hljs-attr\">useValue</span>: <span class=\"hljs-string\">&#x27;http://some-domain.com&#x27;</span>}]});\n<span class=\"hljs-keyword\">const</span> url = injector.get(BASE_URL);</code></pre>\n","level":2},{"slug":"what-is-angular-dsl","title":"What is Angular DSL?","answer":"<p>  A domain-specific language (DSL) is a computer language specialized to a particular application domain. Angular has its own Domain Specific Language (DSL) which allows us to write Angular specific html-like syntax on top of normal html. It has its own compiler that compiles this syntax to html that the browser can understand. This DSL is defined in NgModules such as animations, forms, and routing and navigation.\nBasically you will see 3 main syntax in Angular DSL.</p>\n<ol>\n<li><code>()</code>: Used for Output and DOM events.</li>\n<li><code>[]</code>: Used for Input and specific DOM element attributes.</li>\n<li><code>*</code>: Structural directives(*ngFor or *ngIf) will affect/change the DOM structure.</li>\n</ol>\n","level":2},{"slug":"what-happens-if-i-import-the-same-module-twice","title":"What happens if I import the same module twice?","answer":"<p> If multiple modules imports the same module then angular evaluates it only once (When it encounters the module first time). It follows this condition even the module appears at any level in a hierarchy of imported NgModules.</p>\n","level":2},{"slug":"how-do-you-select-an-element-with-in-a-component-template","title":"How do you select an element with in a component template?","answer":"<p> You can use <code>@ViewChild</code> directive to access elements in the view directly. Let&#39;s take input element with a reference,</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> #<span class=\"hljs-attr\">uname</span>&gt;</span></code></pre>\n<p>and define view child directive and access it in ngAfterViewInit lifecycle hook</p>\n<pre><code class=\"language-javascript\">@ViewChild(<span class=\"hljs-string\">&#x27;uname&#x27;</span>) input;\n<span class=\"hljs-function\"><span class=\"hljs-title\">ngAfterViewInit</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>.input.nativeElement.value);\n}</code></pre>\n","level":2},{"slug":"how-do-you-detect-route-change-in-angular","title":"How do you detect route change in Angular?","answer":"<p> In Angular7, you can subscribe to router to detect the changes. The subscription for router events would be as below,</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-built_in\">this</span>.router.events.subscribe(<span class=\"hljs-function\">(<span class=\"hljs-params\">event: Event</span>) =&gt;</span> {})</code></pre>\n<p>Let&#39;s take a simple component to detect router changes</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { Router, Event, NavigationStart, NavigationEnd, NavigationError } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/router&#x27;</span>;\n@Component({\n<span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;app-root&#x27;</span>,\n<span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;router-outlet&gt;&lt;/router-outlet&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppComponent</span> </span>{\n<span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">private router: Router</span>)</span> {\n<span class=\"hljs-built_in\">this</span>.router.events.subscribe(<span class=\"hljs-function\">(<span class=\"hljs-params\">event: Event</span>) =&gt;</span> {\n<span class=\"hljs-keyword\">if</span> (event <span class=\"hljs-keyword\">instanceof</span> NavigationStart) {\n<span class=\"hljs-comment\">// Show loading indicator and perform an action</span>\n}\n<span class=\"hljs-keyword\">if</span> (event <span class=\"hljs-keyword\">instanceof</span> NavigationEnd) {\n<span class=\"hljs-comment\">// Hide loading indicator and perform an action</span>\n}\n<span class=\"hljs-keyword\">if</span> (event <span class=\"hljs-keyword\">instanceof</span> NavigationError) {\n<span class=\"hljs-comment\">// Hide loading indicator and perform an action</span>\n<span class=\"hljs-built_in\">console</span>.log(event.error); <span class=\"hljs-comment\">// It logs an error for debugging</span>\n}\n});\n}\n}</code></pre>\n","level":2},{"slug":"is-angular-supports-dynamic-imports","title":"Is Angular supports dynamic imports?","answer":"<p> Yes, Angular 8 supports dynamic imports in router configuration. i.e, You can use the import statement for lazy loading the module using <code>loadChildren</code> method and it will be understood by the IDEs(VSCode and WebStorm), webpack, etc.\nPreviously, you have been written as below to lazily load the feature module. By mistake, if you have typo in the module name it still accepts the string and throws an error during build time.</p>\n<pre><code class=\"language-javascript\">{<span class=\"hljs-attr\">path</span>: ‘user’, <span class=\"hljs-attr\">loadChildren</span>: ‘./users/user.module#UserModulee’},</code></pre>\n<p>This problem is resolved by using dynamic imports and IDEs are able to find it during compile time itself.</p>\n<pre><code class=\"language-javascript\">{<span class=\"hljs-attr\">path</span>: ‘user’, <span class=\"hljs-attr\">loadChildren</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(‘./users/user.module’).then(<span class=\"hljs-function\"><span class=\"hljs-params\">m</span> =&gt;</span> m.UserModule)};</code></pre>\n","level":2},{"slug":"what-is-lazy-loading","title":"What is lazy loading?","answer":"<p> Lazy loading is one of the most useful concepts of Angular Routing. It helps us to download the web pages in chunks instead of downloading everything in a big bundle. It is used for lazy loading by asynchronously loading the feature module for routing whenever required using the property <code>loadChildren</code>. Let&#39;s load both <code>Customer</code> and <code>Order</code> feature modules lazily as below,</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">const</span> routes: Routes = [\n{\n<span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;customers&#x27;</span>,\n<span class=\"hljs-attr\">loadChildren</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./customers/customers.module&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">module</span> =&gt;</span> <span class=\"hljs-built_in\">module</span>.CustomersModule)\n},\n{\n<span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;orders&#x27;</span>,\n<span class=\"hljs-attr\">loadChildren</span>: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./orders/orders.module&#x27;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">module</span> =&gt;</span> <span class=\"hljs-built_in\">module</span>.OrdersModule)\n},\n{\n<span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n<span class=\"hljs-attr\">redirectTo</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n<span class=\"hljs-attr\">pathMatch</span>: <span class=\"hljs-string\">&#x27;full&#x27;</span>\n}\n];</code></pre>\n","level":2},{"slug":"what-are-workspace-apis","title":"What are workspace APIs?","answer":"<p> Angular 8.0 release introduces Workspace APIs to make it easier for developers to read and modify the angular.json file instead of manually modifying it. Currently, the only supported storage3 format is the JSON-based format used by the Angular CLI. You can enable or add optimization option for build target as below,</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> { NodeJsSyncHost } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular-devkit/core/node&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { workspaces } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular-devkit/core&#x27;</span>;\n<span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">addBuildTargetOption</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-keyword\">const</span> host = workspaces.createWorkspaceHost(<span class=\"hljs-keyword\">new</span> NodeJsSyncHost());\n<span class=\"hljs-keyword\">const</span> workspace = <span class=\"hljs-keyword\">await</span> workspaces.readWorkspace(<span class=\"hljs-string\">&#x27;path/to/workspace/directory/&#x27;</span>, host);\n<span class=\"hljs-keyword\">const</span> project = workspace.projects.get(<span class=\"hljs-string\">&#x27;my-app&#x27;</span>);\n<span class=\"hljs-keyword\">if</span> (!project) {\n<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;my-app does not exist&#x27;</span>);\n}\n<span class=\"hljs-keyword\">const</span> buildTarget = project.targets.get(<span class=\"hljs-string\">&#x27;build&#x27;</span>);\n<span class=\"hljs-keyword\">if</span> (!buildTarget) {\n<span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;build target does not exist&#x27;</span>);\n}\nbuildTarget.options.optimization = <span class=\"hljs-literal\">true</span>;\n<span class=\"hljs-keyword\">await</span> workspaces.writeWorkspace(workspace, host);\n}\naddBuildTargetOption();</code></pre>\n","level":2},{"slug":"how-do-you-upgrade-angular-version","title":"How do you upgrade angular version?","answer":"<p> The Angular upgrade is quite easier using Angular CLI <code>ng update</code> command as mentioned below. For example, if you upgrade from Angular 7 to 8 then your lazy loaded route imports will be migrated to the new import syntax automatically.</p>\n<pre><code class=\"language-bash\">$ ng update @angular/cli @angular/core</code></pre>\n","level":2},{"slug":"what-is-ngupgrade","title":"What is NgUpgrade?","answer":"<p> NgUpgrade is a library put together by the Angular team, which you can use in your applications to mix and match AngularJS and Angular components and bridge the AngularJS and Angular dependency injection systems.</p>\n","level":2},{"slug":"how-do-you-test-angular-application-using-cli","title":"How do you test Angular application using CLI?","answer":"<p> Angular CLI downloads and install everything needed with the Jasmine Test framework. You just need to run <code>ng test</code> to see the test results. By default this command builds the app in watch mode, and launches the <code>Karma test runner</code>. The output of test results would be as below,</p>\n<pre><code class=\"language-bash\">10% building modules 1/1 modules 0 active\n...INFO [karma]: Karma v1.7.1 server started at http://0.0.0.0:9876/\n...INFO [launcher]: Launching browser Chrome ...\n...INFO [launcher]: Starting browser Chrome\n...INFO [Chrome ...]: Connected on socket ...\nChrome ...: Executed 3 of 3 SUCCESS (0.135 secs / 0.205 secs)</code></pre>\n<p><strong>Note:</strong> A chrome browser also opens and displays the test output in the &quot;Jasmine HTML Reporter&quot;.</p>\n","level":2},{"slug":"how-to-use-polyfills-in-angular-application","title":"How to use polyfills in Angular application?","answer":"<p> The Angular CLI provides support for polyfills officially. When you create a new project with the ng new command, a <code>src/polyfills.ts</code> configuration file is created as part of your project folder. This file includes the mandatory and many of the optional polyfills as JavaScript import statements. Let&#39;s categorize the polyfills,</p>\n<ol>\n<li><strong>Mandatory polyfills:</strong> These are installed automatically when you create your project with ng new command and the respective import statements enabled in &#39;src/polyfills.ts&#39; file.</li>\n<li><strong>Optional polyfills:</strong> You need to install its npm package and then create import statement in &#39;src/polyfills.ts&#39; file.\nFor example, first you need to install below npm package for adding web animations (optional) polyfill.<pre><code class=\"language-bash\">npm install --save web-animations-js</code></pre>\nand create import statement in polyfill file.<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;web-animations-js&#x27;</span>;</code></pre>\n</li>\n</ol>\n","level":2},{"slug":"what-are-the-ways-to-trigger-change-detection-in-angular","title":"What are the ways to trigger change detection in Angular?","answer":"<p> You can inject either ApplicationRef or NgZone, or ChangeDetectorRef into your component and apply below specific methods to trigger change detection in Angular. i.e, There are 3 possible ways,</p>\n<ol>\n<li><strong>ApplicationRef.tick():</strong> Invoke this method to explicitly process change detection and its side-effects. It check the full component tree.</li>\n<li><strong>NgZone.run(callback):</strong> It evaluate the callback function inside the Angular zone.</li>\n<li><strong>ChangeDetectorRef.detectChanges():</strong> It detects only the components and it&#39;s children.</li>\n</ol>\n","level":2},{"slug":"what-is-the-browser-support-for-angular","title":"What is the browser support for Angular?","answer":"<p> Angular supports most recent browsers which includes both desktop and mobile browsers.\n| Browser | Version |\n|---- | --------- |\n| Chrome | latest |\n| Firefox | latest |\n| Edge | 2 most recent major versions |\n| IE | 11, 10, 9 (Compatibility mode is not supported) |\n| Safari | 2 most recent major versions |\n| IE Mobile | 11 |\n| iOS | 2 most recent major versions |\n| Android | 7.0, 6.0, 5.0, 5.1, 4.4 |</p>\n","level":2},{"slug":"what-is-the-purpose-of-innerhtml","title":"What is the purpose of innerHTML?","answer":"<p> The innerHtml is a property of HTML-Elements, which allows you to set it&#39;s html-content programmatically. Let&#39;s display the below html code snippet in a <code>&lt;div&gt;</code> tag as below using innerHTML binding,</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> [<span class=\"hljs-attr\">innerHTML</span>]=<span class=\"hljs-string\">&quot;htmlSnippet&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n<p>and define the htmlSnippet property from any component</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myComponent</span> </span>{\n<span class=\"hljs-attr\">htmlSnippet</span>: string = <span class=\"hljs-string\">&#x27;&lt;b&gt;Hello World&lt;/b&gt;, Angular&#x27;</span>;\n}</code></pre>\n<p>Unfortunately this property could cause Cross Site Scripting (XSS) security bugs when improperly handled.</p>\n","level":2},{"slug":"what-are-http-interceptors","title":"What are Http Interceptors?","answer":"<p> Http Interceptors are part of @angular/common/http, which inspect and transform HTTP requests from your application to the server and vice-versa on HTTP responses. These interceptors can perform a variety of implicit tasks, from authentication to logging.\nThe syntax of HttpInterceptor interface looks like as below,</p>\n<pre><code class=\"language-javascript\">interface HttpInterceptor {\nintercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt;\n}</code></pre>\n<p>You can use interceptors by declaring a service class that implements the intercept() method of the HttpInterceptor interface.</p>\n<pre><code class=\"language-javascript\">@Injectable()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyInterceptor</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">HttpInterceptor</span> </span>{\n<span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> {}\nintercept(req: HttpRequest&lt;any&gt;, next: HttpHandler): Observable&lt;HttpEvent&lt;any&gt;&gt; {\n...\n}\n}</code></pre>\n<p>After that you can use it in your module,</p>\n<pre><code class=\"language-javascript\">@NgModule({\n...\n<span class=\"hljs-attr\">providers</span>: [\n{\n<span class=\"hljs-attr\">provide</span>: HTTP_INTERCEPTORS,\n<span class=\"hljs-attr\">useClass</span>: MyInterceptor,\n<span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span>\n}\n]\n...\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{}</code></pre>\n","level":2},{"slug":"what-are-the-applications-of-http-interceptors","title":"What are the applications of HTTP interceptors?","answer":"<p> The HTTP Interceptors can be used for different variety of tasks,</p>\n<ol>\n<li>Authentication</li>\n<li>Logging</li>\n<li>Caching</li>\n<li>Fake backend</li>\n<li>URL transformation</li>\n<li>Modifying headers</li>\n</ol>\n","level":2},{"slug":"is-multiple-interceptors-supported-in-angular","title":"Is multiple interceptors supported in Angular?","answer":"<p> Yes, Angular supports multiple interceptors at a time. You could define multiple interceptors in providers property:</p>\n<pre><code class=\"language-javascript\">providers: [\n{ <span class=\"hljs-attr\">provide</span>: HTTP_INTERCEPTORS, <span class=\"hljs-attr\">useClass</span>: MyFirstInterceptor, <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span> },\n{ <span class=\"hljs-attr\">provide</span>: HTTP_INTERCEPTORS, <span class=\"hljs-attr\">useClass</span>: MySecondInterceptor, <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span> }\n],</code></pre>\n<p>The interceptors will be called in the order in which they were provided. i.e, MyFirstInterceptor will be called first in the above interceptors configuration.</p>\n","level":2},{"slug":"how-can-i-use-interceptor-for-an-entire-application","title":"How can I use interceptor for an entire application?","answer":"<p> You can use same instance of <code>HttpInterceptors</code> for the entire app by importing the <code>HttpClientModule</code> only in your AppModule, and add the interceptors to the root application injector.\nFor example, let&#39;s define a class that is injectable in root application.</p>\n<pre><code class=\"language-javascript\">@Injectable()\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyInterceptor</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">HttpInterceptor</span> </span>{\nintercept(\nreq: HttpRequest&lt;any&gt;,\nnext: HttpHandler\n): Observable&lt;HttpEvent&lt;any&gt;&gt; {\n<span class=\"hljs-keyword\">return</span> next.handle(req).do(<span class=\"hljs-function\"><span class=\"hljs-params\">event</span> =&gt;</span> {\n<span class=\"hljs-keyword\">if</span> (eventt <span class=\"hljs-keyword\">instanceof</span> HttpResponse) {\n<span class=\"hljs-comment\">// Code goes here</span>\n}\n});\n}\n}</code></pre>\n<p>After that import HttpClientModule in AppModule</p>\n<pre><code class=\"language-javascript\">@NgModule({\n<span class=\"hljs-attr\">declarations</span>: [AppComponent],\n<span class=\"hljs-attr\">imports</span>: [BrowserModule, HttpClientModule],\n<span class=\"hljs-attr\">providers</span>: [\n{ <span class=\"hljs-attr\">provide</span>: HTTP_INTERCEPTORS, <span class=\"hljs-attr\">useClass</span>: MyInterceptor, <span class=\"hljs-attr\">multi</span>: <span class=\"hljs-literal\">true</span> }\n],\n<span class=\"hljs-attr\">bootstrap</span>: [AppComponent]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{}</code></pre>\n","level":2},{"slug":"what-is-an-angular-library","title":"What is an angular library?","answer":"<p> An Angular library is an Angular project that differs from an app in that it cannot run on its own. It must be imported and used in an app. For example,  you can import or add <code>service worker</code> library to an Angular application which turns an application into a Progressive Web App (PWA).\n<strong>Note:</strong> You can create own third party library and publish it as npm package to be used in an Application.</p>\n","level":2},{"slug":"how-do-you-select-an-element-in-component-template","title":"How do you select an element in component template?","answer":"<p> You can control any DOM element via ElementRef by injecting it into your component&#39;s constructor. i.e, The component should have constructor with ElementRef parameter,</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">myElement: ElementRef</span>)</span> {\nel.nativeElement.style.backgroundColor = <span class=\"hljs-string\">&#x27;yellow&#x27;</span>;\n}</code></pre>\n","level":2},{"slug":"what-is-the-purpose-of-hidden-property","title":"What is the purpose of hidden property?","answer":"<p> The hidden property is used  to show or hide the associated DOM element, based on an expression. It can be compared close to <code>ng-show</code> directive in AngularJS. Let&#39;s say you want to show user name based on the availability of user using <code>hidden</code> property.</p>\n<pre><code class=\"language-javascript\">&lt;div [hidden]=<span class=\"hljs-string\">&quot;!user.name&quot;</span>&gt;\nMy name is: {{user.name}}\n&lt;/div&gt;</code></pre>\n","level":2},{"slug":"what-is-the-difference-between-ngif-and-hidden-property","title":"What is the difference between ngIf and hidden property?","answer":"<p> The main difference is that *ngIf will remove the element from the DOM, while [hidden] actually plays with the CSS style by setting <code>display:none</code>. Generally it is expensive to add and remove stuff from the DOM for frequent actions.</p>\n","level":2},{"slug":"what-is-slice-pipe","title":"What is slice pipe?","answer":"<p> The slice pipe is used to create a new Array or String containing a subset (slice) of the elements. The syntax looks like as below,</p>\n<pre><code class=\"language-javascript\">{{ value_expression | slice : start [ : end ] }}</code></pre>\n<p>For example, you can provide &#39;hello&#39; list based on a greeting array,</p>\n<pre><code class=\"language-javascript\">@Component({\n<span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;list-pipe&#x27;</span>,\n<span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`&lt;ul&gt;\n&lt;li *ngFor=&quot;let i of greeting | slice:0:5&quot;&gt;{{i}}&lt;/li&gt;\n&lt;/ul&gt;`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PipeListComponent</span> </span>{\n<span class=\"hljs-attr\">greeting</span>: string[] = [<span class=\"hljs-string\">&#x27;h&#x27;</span>, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;l&#x27;</span>, <span class=\"hljs-string\">&#x27;l&#x27;</span>, <span class=\"hljs-string\">&#x27;o&#x27;</span>, <span class=\"hljs-string\">&#x27;m&#x27;</span>,<span class=\"hljs-string\">&#x27;o&#x27;</span>, <span class=\"hljs-string\">&#x27;r&#x27;</span>, <span class=\"hljs-string\">&#x27;n&#x27;</span>, <span class=\"hljs-string\">&#x27;i&#x27;</span>, <span class=\"hljs-string\">&#x27;n&#x27;</span>, <span class=\"hljs-string\">&#x27;g&#x27;</span>];\n}</code></pre>\n","level":2},{"slug":"what-is-index-property-in-ngfor-directive","title":"What is index property in ngFor directive?","answer":"<p> The index property of the NgFor directive is used to return the zero-based index of the item in each iteration. You can capture the index in a template input variable and use it in the template.\nFor example, you can capture the index in a variable named indexVar and displays it with the todo&#39;s name using ngFor directive as below.</p>\n<pre><code class=\"language-javascript\">&lt;div *ngFor=<span class=\"hljs-string\">&quot;let todo of todos; let i=index&quot;</span>&gt;{{i + <span class=\"hljs-number\">1</span>}} - {{todo.name}}&lt;/div&gt;</code></pre>\n","level":2},{"slug":"what-is-the-purpose-of-ngfor-trackby","title":"What is the purpose of ngFor trackBy?","answer":"<p> The main purpose of using *ngFor with trackBy option is performance optimization. Normally if you use NgFor with large data sets, a small change to one item by removing or adding an item, can trigger a cascade of DOM manipulations. In this case, Angular sees only a fresh list of new object references and to replace the old DOM elements with all new DOM elements. You can help Angular to track which items added or removed by providing a <code>trackBy</code> function which takes the index and the current item as arguments and needs to return the unique identifier for this item.\nFor example, lets set trackBy to the trackByTodos() method</p>\n<pre><code class=\"language-javascript\">&lt;div *ngFor=<span class=\"hljs-string\">&quot;let todo of todos; trackBy: trackByTodos&quot;</span>&gt;\n({{todo.id}}) {{todo.name}}\n&lt;/div&gt;</code></pre>\n<p>and define the trackByTodos method,</p>\n<pre><code class=\"language-javascript\">trackByTodos(index: number, <span class=\"hljs-attr\">item</span>: Todo): number { <span class=\"hljs-keyword\">return</span> todo.id; }</code></pre>\n","level":2},{"slug":"what-is-the-purpose-of-ngswitch-directive","title":"What is the purpose of ngSwitch directive?","answer":"<p> <strong>NgSwitch</strong> directive is similar to JavaScript switch statement which displays one element from among several possible elements, based on a switch condition. In this case only the selected element placed into the DOM. It has been used along with <code>NgSwitch</code>, <code>NgSwitchCase</code> and <code>NgSwitchDefault</code> directives.\nFor example, let&#39;s display the browser details based on selected browser using ngSwitch directive.</p>\n<pre><code class=\"language-javascript\">&lt;div [ngSwitch]=<span class=\"hljs-string\">&quot;currentBrowser.name&quot;</span>&gt;\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">chrome-browser</span>    *<span class=\"hljs-attr\">ngSwitchCase</span>=<span class=\"hljs-string\">&quot;&#x27;chrome&#x27;&quot;</span>    [<span class=\"hljs-attr\">item</span>]=<span class=\"hljs-string\">&quot;currentBrowser&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">chrome-browser</span>&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">firefox-browser</span>   *<span class=\"hljs-attr\">ngSwitchCase</span>=<span class=\"hljs-string\">&quot;&#x27;firefox&#x27;&quot;</span>     [<span class=\"hljs-attr\">item</span>]=<span class=\"hljs-string\">&quot;currentBrowser&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">firefox-browser</span>&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">opera-browser</span>     *<span class=\"hljs-attr\">ngSwitchCase</span>=<span class=\"hljs-string\">&quot;&#x27;opera&#x27;&quot;</span>  [<span class=\"hljs-attr\">item</span>]=<span class=\"hljs-string\">&quot;currentBrowser&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">opera-browser</span>&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">safari-browser</span>     *<span class=\"hljs-attr\">ngSwitchCase</span>=<span class=\"hljs-string\">&quot;&#x27;safari&#x27;&quot;</span>   [<span class=\"hljs-attr\">item</span>]=<span class=\"hljs-string\">&quot;currentBrowser&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">safari-browser</span>&gt;</span></span>\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ie-browser</span>  *<span class=\"hljs-attr\">ngSwitchDefault</span>           [<span class=\"hljs-attr\">item</span>]=<span class=\"hljs-string\">&quot;currentItem&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ie-browser</span>&gt;</span></span>\n&lt;/div&gt;</code></pre>\n","level":2},{"slug":"is-it-possible-to-do-aliasing-for-inputs-and-outputs","title":"Is it possible to do aliasing for inputs and outputs?","answer":"<p> Yes, it is possible to do aliasing for inputs and outputs in two ways.</p>\n<ol>\n<li><strong>Aliasing in metadata:</strong> The inputs and outputs in the metadata aliased using a colon-delimited (:) string with the directive property name on the left and the public alias on the right. i.e. It will be in the format of propertyName:alias.<pre><code class=\"language-javascript\">inputs: [<span class=\"hljs-string\">&#x27;input1: buyItem&#x27;</span>],\n<span class=\"hljs-attr\">outputs</span>: [<span class=\"hljs-string\">&#x27;outputEvent1: completedEvent&#x27;</span>]</code></pre>\n</li>\n<li><strong>Aliasing with @Input()/@Output() decorator:</strong> The alias can be specified for the property name by passing the alias name to the @Input()/@Output() decorator.i.e. It will be in the form of @Input(alias) or @Output(alias).<pre><code class=\"language-javascript\">@Input(<span class=\"hljs-string\">&#x27;buyItem&#x27;</span>) input1: string;\n@Output(<span class=\"hljs-string\">&#x27;completedEvent&#x27;</span>) outputEvent1 = <span class=\"hljs-keyword\">new</span> EventEmitter&lt;string&gt;();</code></pre>\n</li>\n</ol>\n","level":2},{"slug":"what-is-safe-navigation-operator","title":"What is safe navigation operator?","answer":"<p> The safe navigation operator(?)(or known as Elvis Operator) is used to guard against <code>null</code> and <code>undefined</code> values in property paths when you are not aware whether a path exists or not. i.e. It returns value of the object path if it exists, else it returns the null value.\nFor example, you can access nested properties of a user profile easily without null reference errors as below,</p>\n<pre><code class=\"language-javascript\">&lt;p&gt;The user firstName is: {{user?.fullName.firstName}}&lt;/p&gt;</code></pre>\n<p>Using this safe navigation operator, Angular framework stops evaluating the expression when it hits the first null value and renders the view without any errors.</p>\n","level":2},{"slug":"what-are-the-list-of-template-expression-operators","title":"What are the list of template expression operators?","answer":"<p> The Angular template expression language supports three special template expression operators.</p>\n<ol>\n<li>Pipe operator</li>\n<li>Safe navigation operator</li>\n<li>Non-null assertion operator</li>\n</ol>\n","level":2},{"slug":"what-is-an-entry-component","title":"What is an entry component?","answer":"<p> An entry component is any component that Angular loads imperatively(i.e, not referencing it in the template) by type. Due to this behavior, they can’t be found by the Angular compiler during compilation. These components created dynamically with <code>ComponentFactoryResolver</code>.\nBasically, there are two main kinds of entry components which are following -</p>\n<ol>\n<li>The bootstrapped root component</li>\n<li>A component you specify in a route</li>\n<li><h3 id=\"what-is-a-bootstrapped-component\">What is a bootstrapped component?</h3>\nA bootstrapped component is an entry component that Angular loads into the DOM during the bootstrap process or application launch time. Generally, this bootstrapped or root component is named as <code>AppComponent</code> in your root module using <code>bootstrap</code> property as below.<pre><code class=\"language-js\">@NgModule({\n<span class=\"hljs-attr\">declarations</span>: [\nAppComponent\n],\n<span class=\"hljs-attr\">imports</span>: [\nBrowserModule,\nFormsModule,\nHttpClientModule,\nAppRoutingModule\n],\n<span class=\"hljs-attr\">providers</span>: [],\n<span class=\"hljs-attr\">bootstrap</span>: [AppComponent] <span class=\"hljs-comment\">// bootstrapped entry component need to be declared here</span>\n})</code></pre>\n</li>\n<li><h3 id=\"how-do-you-manually-bootstrap-an-application\">How do you manually bootstrap an application?</h3>\nYou can use <code>ngDoBootstrap</code> hook for a manual bootstrapping of the application instead of using bootstrap array in <code>@NgModule</code> annotation. This hook is part of <code>DoBootstap</code> interface.<pre><code class=\"language-js\">interface DoBootstrap {\nngDoBootstrap(appRef: ApplicationRef): <span class=\"hljs-keyword\">void</span>\n}</code></pre>\nThe module needs to be implement the above interface to use the hook for bootstrapping.<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">DoBootstrap</span> </span>{\n<span class=\"hljs-function\"><span class=\"hljs-title\">ngDoBootstrap</span>(<span class=\"hljs-params\">appRef: ApplicationRef</span>)</span> {\nappRef.bootstrap(AppComponent); <span class=\"hljs-comment\">// bootstrapped entry component need to be passed</span>\n}\n}</code></pre>\n</li>\n</ol>\n","level":2},{"slug":"what-is-a-bootstrapped-component","title":"What is a bootstrapped component?","answer":"<p> A bootstrapped component is an entry component that Angular loads into the DOM during the bootstrap process or application launch time. Generally, this bootstrapped or root component is named as <code>AppComponent</code> in your root module using <code>bootstrap</code> property as below.</p>\n<pre><code class=\"language-js\">@NgModule({\n<span class=\"hljs-attr\">declarations</span>: [\nAppComponent\n],\n<span class=\"hljs-attr\">imports</span>: [\nBrowserModule,\nFormsModule,\nHttpClientModule,\nAppRoutingModule\n],\n<span class=\"hljs-attr\">providers</span>: [],\n<span class=\"hljs-attr\">bootstrap</span>: [AppComponent] <span class=\"hljs-comment\">// bootstrapped entry component need to be declared here</span>\n})</code></pre>\n<ol start=\"215\">\n<li><h3 id=\"how-do-you-manually-bootstrap-an-application\">How do you manually bootstrap an application?</h3>\nYou can use <code>ngDoBootstrap</code> hook for a manual bootstrapping of the application instead of using bootstrap array in <code>@NgModule</code> annotation. This hook is part of <code>DoBootstap</code> interface.<pre><code class=\"language-js\">interface DoBootstrap {\nngDoBootstrap(appRef: ApplicationRef): <span class=\"hljs-keyword\">void</span>\n}</code></pre>\nThe module needs to be implement the above interface to use the hook for bootstrapping.<pre><code class=\"language-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> <span class=\"hljs-title\">implements</span> <span class=\"hljs-title\">DoBootstrap</span> </span>{\n<span class=\"hljs-function\"><span class=\"hljs-title\">ngDoBootstrap</span>(<span class=\"hljs-params\">appRef: ApplicationRef</span>)</span> {\nappRef.bootstrap(AppComponent); <span class=\"hljs-comment\">// bootstrapped entry component need to be passed</span>\n}\n}</code></pre>\n</li>\n</ol>\n","level":2},{"slug":"what-is-a-routed-entry-component","title":"What is a routed entry component?","answer":"<p> The components referenced in router configuration are called as routed entry components. This routed entry component defined in a route definition as below,</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> routes: Routes = [\n{\n<span class=\"hljs-attr\">path</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>,\n<span class=\"hljs-attr\">component</span>: TodoListComponent <span class=\"hljs-comment\">// router entry component</span>\n}\n];</code></pre>\n<p>Since router definition requires you to add the component in two places (router and entryComponents), these components are always entry components.\n<strong>Note:</strong> The compilers are smart enough to recognize a router definition and automatically add the router component into <code>entryComponents</code>.</p>\n","level":2},{"slug":"what-is-a-provider","title":"What is a provider?","answer":"<p> A provider is an instruction to the Dependency Injection system on how to obtain a value for a dependency(aka services created). The service can be provided using Angular CLI as below,</p>\n<pre><code class=\"language-javascript\">ng generate service my-service</code></pre>\n<p>The created service by CLI would be as below,</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { Injectable } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n@Injectable({\n<span class=\"hljs-attr\">providedIn</span>: <span class=\"hljs-string\">&#x27;root&#x27;</span>, <span class=\"hljs-comment\">//Angular provide the service in root injector</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyService</span> </span>{\n}</code></pre>\n","level":2},{"slug":"what-is-ngzone","title":"What is NgZone?","answer":"<p> Angular provides a service called NgZone which creates a zone named <code>angular</code> to automatically trigger change detection when the following conditions are satisfied.</p>\n<ol>\n<li>When a sync or async function is executed.</li>\n<li>When there is no microTask scheduled.</li>\n</ol>\n","level":2},{"slug":"what-are-reactive-forms","title":"What are reactive forms?","answer":"<p> Reactive forms is a model-driven approach for creating forms in a reactive style(form inputs changes over time). These are built around observable streams, where form inputs and values are provided as streams of input values. Let&#39;s follow the below steps to create reactive forms,</p>\n<ol>\n<li>Register the reactive forms module which declares reactive-form directives in your app<pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { ReactiveFormsModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms&#x27;</span>;\n@NgModule({\n<span class=\"hljs-attr\">imports</span>: [\n<span class=\"hljs-comment\">// other imports ...</span>\nReactiveFormsModule\n],\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{ }</code></pre>\n</li>\n<li>Create a new FormControl instance and save it in the component.<pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { FormControl } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms&#x27;</span>;\n@Component({\n<span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;user-profile&#x27;</span>,\n<span class=\"hljs-attr\">styleUrls</span>: [<span class=\"hljs-string\">&#x27;./user-profile.component.css&#x27;</span>]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserProfileComponent</span> </span>{\nuserName = <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n}</code></pre>\n</li>\n<li>Register the FormControl in the template.<pre><code class=\"language-js\">&lt;label&gt;\nUser name:\n<span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> [<span class=\"hljs-attr\">formControl</span>]=<span class=\"hljs-string\">&quot;userName&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span></span></code></pre>\nFinally, the component with reactive form control appears as below,<pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { Component } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { FormControl } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms&#x27;</span>;\n@Component({\n<span class=\"hljs-attr\">selector</span>: <span class=\"hljs-string\">&#x27;user-profile&#x27;</span>,\n<span class=\"hljs-attr\">styleUrls</span>: [<span class=\"hljs-string\">&#x27;./user-profile.component.css&#x27;</span>]\n<span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`\n&lt;label&gt;\nUser name:\n&lt;input type=&quot;text&quot; [formControl]=&quot;userName&quot;&gt;\n&lt;/label&gt;\n`</span>\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserProfileComponent</span> </span>{\nuserName = <span class=\"hljs-keyword\">new</span> FormControl(<span class=\"hljs-string\">&#x27;&#x27;</span>);\n}</code></pre>\n</li>\n</ol>\n","level":2},{"slug":"what-are-dynamic-forms","title":"What are dynamic forms?","answer":"<p> Dynamic forms is a pattern in which we build a form dynamically based on metadata that describes a business object model. You can create them based on reactive form API.</p>\n","level":2},{"slug":"what-are-template-driven-forms","title":"What are template driven forms?","answer":"<p> Template driven forms are model-driven forms where you write the logic, validations, controls etc, in the template part of the code using directives. They are suitable for simple scenarios and uses two-way binding with [(ngModel)] syntax.\nFor example, you can create register form easily by following the below simple steps,</p>\n<ol>\n<li>Import the FormsModule into the Application module&#39;s imports array<pre><code class=\"language-js\"><span class=\"hljs-keyword\">import</span> { BrowserModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/platform-browser&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> { NgModule } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/core&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> {FormsModule} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;@angular/forms&#x27;</span>\n<span class=\"hljs-keyword\">import</span> { RegisterComponent } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./app.component&#x27;</span>;\n@NgModule({\n<span class=\"hljs-attr\">declarations</span>: [\nRegisterComponent,\n],\n<span class=\"hljs-attr\">imports</span>: [\nBrowserModule,\nFormsModule\n],\n<span class=\"hljs-attr\">providers</span>: [],\n<span class=\"hljs-attr\">bootstrap</span>: [RegisterComponent]\n})\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AppModule</span> </span>{ }</code></pre>\n</li>\n<li>Bind the form from template to the component using ngModel syntax<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;form-control&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;name&quot;</span>\n<span class=\"hljs-attr\">required</span>\n[(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;model.name&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span></code></pre>\n</li>\n<li> Attach NgForm directive to the <form> tag in order to create FormControl instances and register them<pre><code class=\"language-js\">&lt;form #registerForm=<span class=\"hljs-string\">&quot;ngForm&quot;</span>&gt;</code></pre>\n</li>\n<li>Apply the validation message for form controls<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span>Name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;form-control&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;name&quot;</span>\n<span class=\"hljs-attr\">required</span>\n[(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;model.name&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;name&quot;</span>\n#<span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;ngModel&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> [<span class=\"hljs-attr\">hidden</span>]=<span class=\"hljs-string\">&quot;name.valid || name.pristine&quot;</span>\n<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;alert alert-danger&quot;</span>&gt;</span>\nPlease enter your name\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n<li>Let&#39;s submit the form with ngSubmit directive and add type=&quot;submit&quot; button at the bottom of the form to trigger form submit.<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> (<span class=\"hljs-attr\">ngSubmit</span>)=<span class=\"hljs-string\">&quot;onSubmit()&quot;</span> #<span class=\"hljs-attr\">heroForm</span>=<span class=\"hljs-string\">&quot;ngForm&quot;</span>&gt;</span>\n// Form goes here\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;btn btn-success&quot;</span> [<span class=\"hljs-attr\">disabled</span>]=<span class=\"hljs-string\">&quot;!registerForm.form.valid&quot;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\nFinally, the completed template-driven registration form will be appeared as follow.<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;container&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Registration Form<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> (<span class=\"hljs-attr\">ngSubmit</span>)=<span class=\"hljs-string\">&quot;onSubmit()&quot;</span> #<span class=\"hljs-attr\">registerForm</span>=<span class=\"hljs-string\">&quot;ngForm&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;form-group&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;name&quot;</span>&gt;</span>Name<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;form-control&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;name&quot;</span>\n<span class=\"hljs-attr\">required</span>\n[(<span class=\"hljs-attr\">ngModel</span>)]=<span class=\"hljs-string\">&quot;model.name&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;name&quot;</span>\n#<span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;ngModel&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> [<span class=\"hljs-attr\">hidden</span>]=<span class=\"hljs-string\">&quot;name.valid || name.pristine&quot;</span>\n<span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;alert alert-danger&quot;</span>&gt;</span>\nPlease enter your name\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;submit&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;btn btn-success&quot;</span> [<span class=\"hljs-attr\">disabled</span>]=<span class=\"hljs-string\">&quot;!registerForm.form.valid&quot;</span>&gt;</span>Submit<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n</li>\n</ol>\n","level":2},{"slug":"what-are-the-differences-between-reactive-forms-and-template-driven-forms","title":"What are the differences between reactive forms and template driven forms?","answer":"<p> Below are the main differences between reactive forms and template driven forms\n| Feature | Reactive | Template-Driven |\n|---- |---- | --------- |\n| Form model setup | Created(FormControl instance) in component explicitly | Created by directives  |\n| Data updates | Synchronous | Asynchronous |\n| Form custom validation | Defined as Functions | Defined as Directives |\n| Testing | No interaction with change detection cycle | Need knowledge of the change detection process |\n| Mutability | Immutable(by always returning new value for FormControl instance) | Mutable(Property always modified to new value) |\n| Scalability | More scalable using low-level APIs | Less scalable using due to abstraction on APIs|</p>\n","level":2},{"slug":"how-do-you-update-specific-properties-of-a-form-model","title":"How do you update specific properties of a form model?","answer":"<p> You can use <code>patchValue()</code> method to update specific properties defined in the form model. For example,you can update the name and street of certain profile on click of the update button as shown below.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-title\">updateProfile</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"hljs-built_in\">this</span>.userProfile.patchValue({\n<span class=\"hljs-attr\">firstName</span>: <span class=\"hljs-string\">&#x27;John&#x27;</span>,\n<span class=\"hljs-attr\">address</span>: {\n<span class=\"hljs-attr\">street</span>: <span class=\"hljs-string\">&#x27;98 Crescent Street&#x27;</span>\n}\n});\n}</code></pre>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> (<span class=\"hljs-attr\">click</span>)=<span class=\"hljs-string\">&quot;updateProfile()&quot;</span>&gt;</span>Update Profile<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></code></pre>\n<p>You can also use <code>setValue</code> method to update properties.\n<strong>Note:</strong> Remember to update the properties against the exact model structure.</p>\n","level":2},{"slug":"what-is-the-purpose-of-formbuilder","title":"What is the purpose of FormBuilder?","answer":"<p> FormBuilder is used as syntactic sugar for easily creating instances of a FormControl, FormGroup, or FormArray. This is helpful to reduce the amount of boilerplate needed to build complex reactive forms. It is available as an injectable helper class of the <code>@angular/forms</code> package.\nFor example, the user profile component creation becomes easier as shown here.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserProfileComponent</span> </span>{\nprofileForm = <span class=\"hljs-built_in\">this</span>.formBuilder.group({\n<span class=\"hljs-attr\">firstName</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],\n<span class=\"hljs-attr\">lastName</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],\n<span class=\"hljs-attr\">address</span>: <span class=\"hljs-built_in\">this</span>.formBuilder.group({\n<span class=\"hljs-attr\">street</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],\n<span class=\"hljs-attr\">city</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],\n<span class=\"hljs-attr\">state</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>],\n<span class=\"hljs-attr\">zip</span>: [<span class=\"hljs-string\">&#x27;&#x27;</span>]\n}),\n});\n<span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">private formBuilder: FormBuilder</span>)</span> { }\n}</code></pre>\n","level":2},{"slug":"how-do-you-verify-the-model-changes-in-forms","title":"How do you verify the model changes in forms?","answer":"<p> You can add a getter property(let&#39;s say, diagnostic) inside component to return a JSON representation of the model during the development. This is useful to verify whether the values are really flowing from the input box to the model and vice versa or not.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">UserProfileComponent</span> </span>{\nmodel = <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-string\">&#x27;John&#x27;</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-string\">&#x27;Writer&#x27;</span>);\n<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">TODO:</span> Remove after the verification</span>\n<span class=\"hljs-keyword\">get</span> <span class=\"hljs-title\">diagnostic</span>() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">JSON</span>.stringify(<span class=\"hljs-built_in\">this</span>.model); }\n}</code></pre>\n<p>and add <code>diagnostic</code> binding near the top of the form</p>\n<pre><code class=\"language-html\">{{diagnostic}}\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;form-group&quot;</span>&gt;</span>\n// FormControls goes here\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre>\n","level":2},{"slug":"how-do-you-reset-the-form","title":"How do you reset the form?","answer":"<p> In a model-driven form, you can reset the form just by calling the function <code>reset()</code> on our form model.\nFor example, you can reset the form model on submission as follows,</p>\n<pre><code class=\"language-js\"><span class=\"hljs-function\"><span class=\"hljs-title\">onSubmit</span>(<span class=\"hljs-params\"></span>)</span> {\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.myform.valid) {\n<span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Form is submitted&quot;</span>);\n<span class=\"hljs-comment\">// Perform business logic here</span>\n<span class=\"hljs-built_in\">this</span>.myform.reset();\n}\n}</code></pre>\n<p>Now, your form model resets the form back to its original pristine state.</p>\n","level":2},{"slug":"how-to-set-ngfor-and-ngif-on-the-same-element","title":"How to set ngFor and ngIf on the same element?","answer":"<p> Sometimes you may need to both ngFor and ngIf on the same element but unfortunately you are going to encounter below template error.</p>\n<pre><code class=\"language-cmd\">Template parse errors: Can&#x27;t have multiple template bindings on one element.</code></pre>\n<p>In this case, You need to use either ng-container or ng-template.\nLet&#39;s say if you try to loop over the items only when the items are available, the below code throws an error in the browser</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;items&quot;</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let item of items&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span></code></pre>\n<p>and it can be fixed by</p>\n<pre><code class=\"language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ng-container</span> *<span class=\"hljs-attr\">ngIf</span>=<span class=\"hljs-string\">&quot;items&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> *<span class=\"hljs-attr\">ngFor</span>=<span class=\"hljs-string\">&quot;let item of items&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ng-container</span>&gt;</span></code></pre>\n","level":2}],"tabs":[{"label":"Junior","slug":"junior","link":"/topics/angular/1"},{"label":"Middle","slug":"middle","link":"/topics/angular/2"},{"label":"Senior","slug":"senior","link":"/topics/angular/3"}],"title":"Questions","topic":{"id":"","image":"/img/topics/angular.svg","slug":"angular","label":"Angular"}},"__N_SSG":true}